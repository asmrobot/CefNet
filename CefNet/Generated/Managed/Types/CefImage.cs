// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_image_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Container for a single image represented at different scale factors. All
	/// image representations should be the same size in density independent pixel
	/// (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels
	/// then the image at scale factor 2.0 should be 200x200 pixels -- both images
	/// will display with a DIP size of 100x100 units. The functions of this
	/// structure can be called on any browser process thread.
	/// </summary>
	/// <remarks>
	/// Role: Proxy
	/// </remarks>
	public unsafe partial class CefImage : CefBaseRefCounted<cef_image_t>
	{
		internal static unsafe CefImage Create(IntPtr instance)
		{
			return new CefImage((cef_image_t*)instance);
		}

		public CefImage(cef_image_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		/// <summary>
		/// Gets a value indicating whether this Image is NULL.
		/// </summary>
		public unsafe virtual bool IsEmpty
		{
			get
			{
				return SafeCall(NativeInstance->IsEmpty() != 0);
			}
		}

		/// <summary>
		/// Gets the image width in density independent pixel (DIP) units.
		/// </summary>
		public unsafe virtual long Width
		{
			get
			{
				return SafeCall((long)NativeInstance->GetWidth());
			}
		}

		/// <summary>
		/// Gets the image height in density independent pixel (DIP) units.
		/// </summary>
		public unsafe virtual long Height
		{
			get
			{
				return SafeCall((long)NativeInstance->GetHeight());
			}
		}

		/// <summary>
		/// Returns true (1) if this Image and |that| Image share the same underlying
		/// storage. Will also return true (1) if both images are NULL.
		/// </summary>
		public unsafe virtual bool IsSame(CefImage that)
		{
			return SafeCall(NativeInstance->IsSame((that != null) ? that.GetNativeInstance() : null) != 0);
		}

		/// <summary>
		/// Add a bitmap image representation for |scale_factor|. Only 32-bit RGBA/BGRA
		/// formats are supported. |pixel_width| and |pixel_height| are the bitmap
		/// representation size in pixel coordinates. |pixel_data| is the array of
		/// pixel data and should be |pixel_width| x |pixel_height| x 4 bytes in size.
		/// |color_type| and |alpha_type| values specify the pixel format.
		/// </summary>
		public unsafe virtual int AddBitmap(float scaleFactor, int pixelWidth, int pixelHeight, CefColorType colorType, CefAlphaType alphaType, IntPtr pixelData, long pixelDataSize)
		{
			return SafeCall(NativeInstance->AddBitmap(scaleFactor, pixelWidth, pixelHeight, colorType, alphaType, (void*)pixelData, new UIntPtr((ulong)pixelDataSize)));
		}

		/// <summary>
		/// Add a PNG image representation for |scale_factor|. |png_data| is the image
		/// data of size |png_data_size|. Any alpha transparency in the PNG data will
		/// be maintained.
		/// </summary>
		public unsafe virtual int AddPng(float scaleFactor, IntPtr pngData, long pngDataSize)
		{
			return SafeCall(NativeInstance->AddPng(scaleFactor, (void*)pngData, new UIntPtr((ulong)pngDataSize)));
		}

		/// <summary>
		/// Create a JPEG image representation for |scale_factor|. |jpeg_data| is the
		/// image data of size |jpeg_data_size|. The JPEG format does not support
		/// transparency so the alpha byte will be set to 0xFF for all pixels.
		/// </summary>
		public unsafe virtual int AddJpeg(float scaleFactor, IntPtr jpegData, long jpegDataSize)
		{
			return SafeCall(NativeInstance->AddJpeg(scaleFactor, (void*)jpegData, new UIntPtr((ulong)jpegDataSize)));
		}

		/// <summary>
		/// Returns true (1) if this image contains a representation for
		/// |scale_factor|.
		/// </summary>
		public unsafe virtual bool HasRepresentation(float scaleFactor)
		{
			return SafeCall(NativeInstance->HasRepresentation(scaleFactor) != 0);
		}

		/// <summary>
		/// Removes the representation for |scale_factor|. Returns true (1) on success.
		/// </summary>
		public unsafe virtual bool RemoveRepresentation(float scaleFactor)
		{
			return SafeCall(NativeInstance->RemoveRepresentation(scaleFactor) != 0);
		}

		/// <summary>
		/// Returns information for the representation that most closely matches
		/// |scale_factor|. |actual_scale_factor| is the actual scale factor for the
		/// representation. |pixel_width| and |pixel_height| are the representation
		/// size in pixel coordinates. Returns true (1) on success.
		/// </summary>
		public unsafe virtual bool GetRepresentationInfo(float scaleFactor, ref float actualScaleFactor, ref int pixelWidth, ref int pixelHeight)
		{
			fixed (float* p1 = &actualScaleFactor)
			fixed (int* p2 = &pixelWidth)
			fixed (int* p3 = &pixelHeight)
			{
				return SafeCall(NativeInstance->GetRepresentationInfo(scaleFactor, p1, p2, p3) != 0);
			}
		}

		/// <summary>
		/// Returns the bitmap representation that most closely matches |scale_factor|.
		/// Only 32-bit RGBA/BGRA formats are supported. |color_type| and |alpha_type|
		/// values specify the desired output pixel format. |pixel_width| and
		/// |pixel_height| are the output representation size in pixel coordinates.
		/// Returns a cef_binary_value_t containing the pixel data on success or NULL
		/// on failure.
		/// </summary>
		public unsafe virtual CefBinaryValue GetAsBitmap(float scaleFactor, CefColorType colorType, CefAlphaType alphaType, ref int pixelWidth, ref int pixelHeight)
		{
			fixed (int* p3 = &pixelWidth)
			fixed (int* p4 = &pixelHeight)
			{
				return SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetAsBitmap(scaleFactor, colorType, alphaType, p3, p4)));
			}
		}

		/// <summary>
		/// Returns the PNG representation that most closely matches |scale_factor|. If
		/// |with_transparency| is true (1) any alpha transparency in the image will be
		/// represented in the resulting PNG data. |pixel_width| and |pixel_height| are
		/// the output representation size in pixel coordinates. Returns a
		/// cef_binary_value_t containing the PNG image data on success or NULL on
		/// failure.
		/// </summary>
		public unsafe virtual CefBinaryValue GetAsPng(float scaleFactor, bool withTransparency, ref int pixelWidth, ref int pixelHeight)
		{
			fixed (int* p2 = &pixelWidth)
			fixed (int* p3 = &pixelHeight)
			{
				return SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetAsPng(scaleFactor, withTransparency ? 1 : 0, p2, p3)));
			}
		}

		/// <summary>
		/// Returns the JPEG representation that most closely matches |scale_factor|.
		/// |quality| determines the compression level with 0 == lowest and 100 ==
		/// highest. The JPEG format does not support alpha transparency and the alpha
		/// channel, if any, will be discarded. |pixel_width| and |pixel_height| are
		/// the output representation size in pixel coordinates. Returns a
		/// cef_binary_value_t containing the JPEG image data on success or NULL on
		/// failure.
		/// </summary>
		public unsafe virtual CefBinaryValue GetAsJpeg(float scaleFactor, bool quality, ref int pixelWidth, ref int pixelHeight)
		{
			fixed (int* p2 = &pixelWidth)
			fixed (int* p3 = &pixelHeight)
			{
				return SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetAsJpeg(scaleFactor, quality ? 1 : 0, p2, p3)));
			}
		}
	}
}
