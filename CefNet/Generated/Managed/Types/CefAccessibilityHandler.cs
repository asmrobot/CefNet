// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_accessibility_handler_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Implement this structure to receive accessibility notification when
	/// accessibility events have been registered. The functions of this structure
	/// will be called on the UI thread.
	/// </summary>
	/// <remarks>
	/// Role: Handler
	/// </remarks>
	public unsafe partial class CefAccessibilityHandler : CefBaseRefCounted<cef_accessibility_handler_t>, ICefAccessibilityHandlerPrivate
	{
#if NET_LESS_5_0
		private static readonly OnAccessibilityTreeChangeDelegate fnOnAccessibilityTreeChange = OnAccessibilityTreeChangeImpl;

		private static readonly OnAccessibilityLocationChangeDelegate fnOnAccessibilityLocationChange = OnAccessibilityLocationChangeImpl;

#endif // NET_LESS_5_0
		internal static unsafe CefAccessibilityHandler Create(IntPtr instance)
		{
			return new CefAccessibilityHandler((cef_accessibility_handler_t*)instance);
		}

		public CefAccessibilityHandler()
		{
			cef_accessibility_handler_t* self = this.NativeInstance;
			#if NET_LESS_5_0
			self->on_accessibility_tree_change = (void*)Marshal.GetFunctionPointerForDelegate(fnOnAccessibilityTreeChange);
			self->on_accessibility_location_change = (void*)Marshal.GetFunctionPointerForDelegate(fnOnAccessibilityLocationChange);
			#else
			self->on_accessibility_tree_change = (delegate* unmanaged[Stdcall]<cef_accessibility_handler_t*, cef_value_t*, void>)&OnAccessibilityTreeChangeImpl;
			self->on_accessibility_location_change = (delegate* unmanaged[Stdcall]<cef_accessibility_handler_t*, cef_value_t*, void>)&OnAccessibilityLocationChangeImpl;
			#endif
		}

		public CefAccessibilityHandler(cef_accessibility_handler_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefAccessibilityHandlerPrivate.AvoidOnAccessibilityTreeChange();

		/// <summary>
		/// Called after renderer process sends accessibility tree changes to the
		/// browser process.
		/// </summary>
		protected internal unsafe virtual void OnAccessibilityTreeChange(CefValue value)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnAccessibilityTreeChangeDelegate(cef_accessibility_handler_t* self, cef_value_t* value);

#endif // NET_LESS_5_0
		// void (*)(_cef_accessibility_handler_t* self, _cef_value_t* value)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnAccessibilityTreeChangeImpl(cef_accessibility_handler_t* self, cef_value_t* value)
		{
			var instance = GetInstance((IntPtr)self) as CefAccessibilityHandler;
			if (instance == null || ((ICefAccessibilityHandlerPrivate)instance).AvoidOnAccessibilityTreeChange())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)value);
				return;
			}
			instance.OnAccessibilityTreeChange(CefValue.Wrap(CefValue.Create, value));
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefAccessibilityHandlerPrivate.AvoidOnAccessibilityLocationChange();

		/// <summary>
		/// Called after renderer process sends accessibility location changes to the
		/// browser process.
		/// </summary>
		protected internal unsafe virtual void OnAccessibilityLocationChange(CefValue value)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnAccessibilityLocationChangeDelegate(cef_accessibility_handler_t* self, cef_value_t* value);

#endif // NET_LESS_5_0
		// void (*)(_cef_accessibility_handler_t* self, _cef_value_t* value)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnAccessibilityLocationChangeImpl(cef_accessibility_handler_t* self, cef_value_t* value)
		{
			var instance = GetInstance((IntPtr)self) as CefAccessibilityHandler;
			if (instance == null || ((ICefAccessibilityHandlerPrivate)instance).AvoidOnAccessibilityLocationChange())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)value);
				return;
			}
			instance.OnAccessibilityLocationChange(CefValue.Wrap(CefValue.Create, value));
		}
	}
}
