// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_dev_tools_message_observer_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The
	/// functions of this structure will be called on the browser process UI thread.
	/// </summary>
	/// <remarks>
	/// Role: Handler
	/// </remarks>
	public unsafe partial class CefDevToolsMessageObserver : CefBaseRefCounted<cef_dev_tools_message_observer_t>, ICefDevToolsMessageObserverPrivate
	{
#if NET_LESS_5_0
		private static readonly OnDevToolsMessageDelegate fnOnDevToolsMessage = OnDevToolsMessageImpl;

		private static readonly OnDevToolsMethodResultDelegate fnOnDevToolsMethodResult = OnDevToolsMethodResultImpl;

		private static readonly OnDevToolsEventDelegate fnOnDevToolsEvent = OnDevToolsEventImpl;

		private static readonly OnDevToolsAgentAttachedDelegate fnOnDevToolsAgentAttached = OnDevToolsAgentAttachedImpl;

		private static readonly OnDevToolsAgentDetachedDelegate fnOnDevToolsAgentDetached = OnDevToolsAgentDetachedImpl;

#endif // NET_LESS_5_0
		internal static unsafe CefDevToolsMessageObserver Create(IntPtr instance)
		{
			return new CefDevToolsMessageObserver((cef_dev_tools_message_observer_t*)instance);
		}

		public CefDevToolsMessageObserver()
		{
			cef_dev_tools_message_observer_t* self = this.NativeInstance;
			#if NET_LESS_5_0
			self->on_dev_tools_message = (void*)Marshal.GetFunctionPointerForDelegate(fnOnDevToolsMessage);
			self->on_dev_tools_method_result = (void*)Marshal.GetFunctionPointerForDelegate(fnOnDevToolsMethodResult);
			self->on_dev_tools_event = (void*)Marshal.GetFunctionPointerForDelegate(fnOnDevToolsEvent);
			self->on_dev_tools_agent_attached = (void*)Marshal.GetFunctionPointerForDelegate(fnOnDevToolsAgentAttached);
			self->on_dev_tools_agent_detached = (void*)Marshal.GetFunctionPointerForDelegate(fnOnDevToolsAgentDetached);
			#else
			self->on_dev_tools_message = (delegate* unmanaged[Stdcall]<cef_dev_tools_message_observer_t*, cef_browser_t*, void*, UIntPtr, int>)&OnDevToolsMessageImpl;
			self->on_dev_tools_method_result = (delegate* unmanaged[Stdcall]<cef_dev_tools_message_observer_t*, cef_browser_t*, int, int, void*, UIntPtr, void>)&OnDevToolsMethodResultImpl;
			self->on_dev_tools_event = (delegate* unmanaged[Stdcall]<cef_dev_tools_message_observer_t*, cef_browser_t*, cef_string_t*, void*, UIntPtr, void>)&OnDevToolsEventImpl;
			self->on_dev_tools_agent_attached = (delegate* unmanaged[Stdcall]<cef_dev_tools_message_observer_t*, cef_browser_t*, void>)&OnDevToolsAgentAttachedImpl;
			self->on_dev_tools_agent_detached = (delegate* unmanaged[Stdcall]<cef_dev_tools_message_observer_t*, cef_browser_t*, void>)&OnDevToolsAgentDetachedImpl;
			#endif
		}

		public CefDevToolsMessageObserver(cef_dev_tools_message_observer_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefDevToolsMessageObserverPrivate.AvoidOnDevToolsMessage();

		/// <summary>
		/// Method that will be called on receipt of a DevTools protocol message.
		/// |browser| is the originating browser instance. |message| is a UTF8-encoded
		/// JSON dictionary representing either a function result or an event.
		/// |message| is only valid for the scope of this callback and should be copied
		/// if necessary. Return true (1) if the message was handled or false (0) if
		/// the message should be further processed and passed to the
		/// OnDevToolsMethodResult or OnDevToolsEvent functions as appropriate.
		/// Method result dictionaries include an &quot;id&quot; (int) value that identifies the
		/// orginating function call sent from cef_browser_host_t::SendDevToolsMessage,
		/// and optionally either a &quot;result&quot; (dictionary) or &quot;error&quot; (dictionary)
		/// value. The &quot;error&quot; dictionary will contain &quot;code&quot; (int) and &quot;message&quot;
		/// (string) values. Event dictionaries include a &quot;function&quot; (string) value and
		/// optionally a &quot;params&quot; (dictionary) value. See the DevTools protocol
		/// documentation at https://chromedevtools.github.io/devtools-protocol/ for
		/// details of supported function calls and the expected &quot;result&quot; or &quot;params&quot;
		/// dictionary contents. JSON dictionaries can be parsed using the CefParseJSON
		/// function if desired, however be aware of performance considerations when
		/// parsing large messages (some of which may exceed 1MB in size).
		/// </summary>
		protected internal unsafe virtual bool OnDevToolsMessage(CefBrowser browser, IntPtr message, long messageSize)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int OnDevToolsMessageDelegate(cef_dev_tools_message_observer_t* self, cef_browser_t* browser, void* message, UIntPtr message_size);

#endif // NET_LESS_5_0
		// int (*)(_cef_dev_tools_message_observer_t* self, _cef_browser_t* browser, const void* message, size_t message_size)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int OnDevToolsMessageImpl(cef_dev_tools_message_observer_t* self, cef_browser_t* browser, void* message, UIntPtr message_size)
		{
			var instance = GetInstance((IntPtr)self) as CefDevToolsMessageObserver;
			if (instance == null || ((ICefDevToolsMessageObserverPrivate)instance).AvoidOnDevToolsMessage())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				return default;
			}
			return instance.OnDevToolsMessage(CefBrowser.Wrap(CefBrowser.Create, browser), unchecked((IntPtr)message), (long)message_size) ? 1 : 0;
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefDevToolsMessageObserverPrivate.AvoidOnDevToolsMethodResult();

		/// <summary>
		/// Method that will be called after attempted execution of a DevTools protocol
		/// function. |browser| is the originating browser instance. |message_id| is
		/// the &quot;id&quot; value that identifies the originating function call message. If
		/// the function succeeded |success| will be true (1) and |result| will be the
		/// UTF8-encoded JSON &quot;result&quot; dictionary value (which may be NULL). If the
		/// function failed |success| will be false (0) and |result| will be the
		/// UTF8-encoded JSON &quot;error&quot; dictionary value. |result| is only valid for the
		/// scope of this callback and should be copied if necessary. See the
		/// OnDevToolsMessage documentation for additional details on |result|
		/// contents.
		/// </summary>
		protected internal unsafe virtual void OnDevToolsMethodResult(CefBrowser browser, int messageId, bool success, IntPtr result, long resultSize)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnDevToolsMethodResultDelegate(cef_dev_tools_message_observer_t* self, cef_browser_t* browser, int message_id, int success, void* result, UIntPtr result_size);

#endif // NET_LESS_5_0
		// void (*)(_cef_dev_tools_message_observer_t* self, _cef_browser_t* browser, int message_id, int success, const void* result, size_t result_size)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnDevToolsMethodResultImpl(cef_dev_tools_message_observer_t* self, cef_browser_t* browser, int message_id, int success, void* result, UIntPtr result_size)
		{
			var instance = GetInstance((IntPtr)self) as CefDevToolsMessageObserver;
			if (instance == null || ((ICefDevToolsMessageObserverPrivate)instance).AvoidOnDevToolsMethodResult())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				return;
			}
			instance.OnDevToolsMethodResult(CefBrowser.Wrap(CefBrowser.Create, browser), message_id, success != 0, unchecked((IntPtr)result), (long)result_size);
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefDevToolsMessageObserverPrivate.AvoidOnDevToolsEvent();

		/// <summary>
		/// Method that will be called on receipt of a DevTools protocol event.
		/// |browser| is the originating browser instance. |function| is the &quot;function&quot;
		/// value. |params| is the UTF8-encoded JSON &quot;params&quot; dictionary value (which
		/// may be NULL). |params| is only valid for the scope of this callback and
		/// should be copied if necessary. See the OnDevToolsMessage documentation for
		/// additional details on |params| contents.
		/// </summary>
		protected internal unsafe virtual void OnDevToolsEvent(CefBrowser browser, string method, IntPtr @params, long paramsSize)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnDevToolsEventDelegate(cef_dev_tools_message_observer_t* self, cef_browser_t* browser, cef_string_t* method, void* @params, UIntPtr params_size);

#endif // NET_LESS_5_0
		// void (*)(_cef_dev_tools_message_observer_t* self, _cef_browser_t* browser, const cef_string_t* method, const void* params, size_t params_size)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnDevToolsEventImpl(cef_dev_tools_message_observer_t* self, cef_browser_t* browser, cef_string_t* method, void* @params, UIntPtr params_size)
		{
			var instance = GetInstance((IntPtr)self) as CefDevToolsMessageObserver;
			if (instance == null || ((ICefDevToolsMessageObserverPrivate)instance).AvoidOnDevToolsEvent())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				return;
			}
			instance.OnDevToolsEvent(CefBrowser.Wrap(CefBrowser.Create, browser), CefString.Read(method), unchecked((IntPtr)@params), (long)params_size);
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefDevToolsMessageObserverPrivate.AvoidOnDevToolsAgentAttached();

		/// <summary>
		/// Method that will be called when the DevTools agent has attached. |browser|
		/// is the originating browser instance. This will generally occur in response
		/// to the first message sent while the agent is detached.
		/// </summary>
		protected internal unsafe virtual void OnDevToolsAgentAttached(CefBrowser browser)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnDevToolsAgentAttachedDelegate(cef_dev_tools_message_observer_t* self, cef_browser_t* browser);

#endif // NET_LESS_5_0
		// void (*)(_cef_dev_tools_message_observer_t* self, _cef_browser_t* browser)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnDevToolsAgentAttachedImpl(cef_dev_tools_message_observer_t* self, cef_browser_t* browser)
		{
			var instance = GetInstance((IntPtr)self) as CefDevToolsMessageObserver;
			if (instance == null || ((ICefDevToolsMessageObserverPrivate)instance).AvoidOnDevToolsAgentAttached())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				return;
			}
			instance.OnDevToolsAgentAttached(CefBrowser.Wrap(CefBrowser.Create, browser));
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefDevToolsMessageObserverPrivate.AvoidOnDevToolsAgentDetached();

		/// <summary>
		/// Method that will be called when the DevTools agent has detached. |browser|
		/// is the originating browser instance. Any function results that were pending
		/// before the agent became detached will not be delivered, and any active
		/// event subscriptions will be canceled.
		/// </summary>
		protected internal unsafe virtual void OnDevToolsAgentDetached(CefBrowser browser)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnDevToolsAgentDetachedDelegate(cef_dev_tools_message_observer_t* self, cef_browser_t* browser);

#endif // NET_LESS_5_0
		// void (*)(_cef_dev_tools_message_observer_t* self, _cef_browser_t* browser)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnDevToolsAgentDetachedImpl(cef_dev_tools_message_observer_t* self, cef_browser_t* browser)
		{
			var instance = GetInstance((IntPtr)self) as CefDevToolsMessageObserver;
			if (instance == null || ((ICefDevToolsMessageObserverPrivate)instance).AvoidOnDevToolsAgentDetached())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				return;
			}
			instance.OnDevToolsAgentDetached(CefBrowser.Wrap(CefBrowser.Create, browser));
		}
	}
}
