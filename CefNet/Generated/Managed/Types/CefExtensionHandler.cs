// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_extension_handler_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Implement this structure to handle events related to browser extensions. The
	/// functions of this structure will be called on the UI thread. See
	/// cef_request_context_t::LoadExtension for information about extension loading.
	/// </summary>
	/// <remarks>
	/// Role: Handler
	/// </remarks>
	public unsafe partial class CefExtensionHandler : CefBaseRefCounted<cef_extension_handler_t>, ICefExtensionHandlerPrivate
	{
#if NET_LESS_5_0
		private static readonly OnExtensionLoadFailedDelegate fnOnExtensionLoadFailed = OnExtensionLoadFailedImpl;

		private static readonly OnExtensionLoadedDelegate fnOnExtensionLoaded = OnExtensionLoadedImpl;

		private static readonly OnExtensionUnloadedDelegate fnOnExtensionUnloaded = OnExtensionUnloadedImpl;

		private static readonly OnBeforeBackgroundBrowserDelegate fnOnBeforeBackgroundBrowser = OnBeforeBackgroundBrowserImpl;

		private static readonly OnBeforeBrowserDelegate fnOnBeforeBrowser = OnBeforeBrowserImpl;

		private static readonly GetActiveBrowserDelegate fnGetActiveBrowser = GetActiveBrowserImpl;

		private static readonly CanAccessBrowserDelegate fnCanAccessBrowser = CanAccessBrowserImpl;

		private static readonly GetExtensionResourceDelegate fnGetExtensionResource = GetExtensionResourceImpl;

#endif // NET_LESS_5_0
		internal static unsafe CefExtensionHandler Create(IntPtr instance)
		{
			return new CefExtensionHandler((cef_extension_handler_t*)instance);
		}

		public CefExtensionHandler()
		{
			cef_extension_handler_t* self = this.NativeInstance;
			#if NET_LESS_5_0
			self->on_extension_load_failed = (void*)Marshal.GetFunctionPointerForDelegate(fnOnExtensionLoadFailed);
			self->on_extension_loaded = (void*)Marshal.GetFunctionPointerForDelegate(fnOnExtensionLoaded);
			self->on_extension_unloaded = (void*)Marshal.GetFunctionPointerForDelegate(fnOnExtensionUnloaded);
			self->on_before_background_browser = (void*)Marshal.GetFunctionPointerForDelegate(fnOnBeforeBackgroundBrowser);
			self->on_before_browser = (void*)Marshal.GetFunctionPointerForDelegate(fnOnBeforeBrowser);
			self->get_active_browser = (void*)Marshal.GetFunctionPointerForDelegate(fnGetActiveBrowser);
			self->can_access_browser = (void*)Marshal.GetFunctionPointerForDelegate(fnCanAccessBrowser);
			self->get_extension_resource = (void*)Marshal.GetFunctionPointerForDelegate(fnGetExtensionResource);
			#else
			self->on_extension_load_failed = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, CefErrorCode, void>)&OnExtensionLoadFailedImpl;
			self->on_extension_loaded = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, cef_extension_t*, void>)&OnExtensionLoadedImpl;
			self->on_extension_unloaded = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, cef_extension_t*, void>)&OnExtensionUnloadedImpl;
			self->on_before_background_browser = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, cef_extension_t*, cef_string_t*, cef_client_t**, cef_browser_settings_t*, int>)&OnBeforeBackgroundBrowserImpl;
			self->on_before_browser = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, cef_extension_t*, cef_browser_t*, cef_browser_t*, int, cef_string_t*, int, cef_window_info_t*, cef_client_t**, cef_browser_settings_t*, int>)&OnBeforeBrowserImpl;
			self->get_active_browser = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, cef_extension_t*, cef_browser_t*, int, cef_browser_t*>)&GetActiveBrowserImpl;
			self->can_access_browser = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, cef_extension_t*, cef_browser_t*, int, cef_browser_t*, int>)&CanAccessBrowserImpl;
			self->get_extension_resource = (delegate* unmanaged[Stdcall]<cef_extension_handler_t*, cef_extension_t*, cef_browser_t*, cef_string_t*, cef_get_extension_resource_callback_t*, int>)&GetExtensionResourceImpl;
			#endif
		}

		public CefExtensionHandler(cef_extension_handler_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidOnExtensionLoadFailed();

		/// <summary>
		/// Called if the cef_request_context_t::LoadExtension request fails. |result|
		/// will be the error code.
		/// </summary>
		protected internal unsafe virtual void OnExtensionLoadFailed(CefErrorCode result)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnExtensionLoadFailedDelegate(cef_extension_handler_t* self, CefErrorCode result);

#endif // NET_LESS_5_0
		// void (*)(_cef_extension_handler_t* self, cef_errorcode_t result)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnExtensionLoadFailedImpl(cef_extension_handler_t* self, CefErrorCode result)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidOnExtensionLoadFailed())
			{
				return;
			}
			instance.OnExtensionLoadFailed(result);
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidOnExtensionLoaded();

		/// <summary>
		/// Called if the cef_request_context_t::LoadExtension request succeeds.
		/// |extension| is the loaded extension.
		/// </summary>
		protected internal unsafe virtual void OnExtensionLoaded(CefExtension extension)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnExtensionLoadedDelegate(cef_extension_handler_t* self, cef_extension_t* extension);

#endif // NET_LESS_5_0
		// void (*)(_cef_extension_handler_t* self, _cef_extension_t* extension)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnExtensionLoadedImpl(cef_extension_handler_t* self, cef_extension_t* extension)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidOnExtensionLoaded())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)extension);
				return;
			}
			instance.OnExtensionLoaded(CefExtension.Wrap(CefExtension.Create, extension));
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidOnExtensionUnloaded();

		/// <summary>
		/// Called after the cef_extension_t::Unload request has completed.
		/// </summary>
		protected internal unsafe virtual void OnExtensionUnloaded(CefExtension extension)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnExtensionUnloadedDelegate(cef_extension_handler_t* self, cef_extension_t* extension);

#endif // NET_LESS_5_0
		// void (*)(_cef_extension_handler_t* self, _cef_extension_t* extension)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnExtensionUnloadedImpl(cef_extension_handler_t* self, cef_extension_t* extension)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidOnExtensionUnloaded())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)extension);
				return;
			}
			instance.OnExtensionUnloaded(CefExtension.Wrap(CefExtension.Create, extension));
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidOnBeforeBackgroundBrowser();

		/// <summary>
		/// Called when an extension needs a browser to host a background script
		/// specified via the &quot;background&quot; manifest key. The browser will have no
		/// visible window and cannot be displayed. |extension| is the extension that
		/// is loading the background script. |url| is an internally generated
		/// reference to an HTML page that will be used to load the background script
		/// via a
		/// &lt;script
		/// &gt; src attribute. To allow creation of the browser optionally
		/// modify |client| and |settings| and return false (0). To cancel creation of
		/// the browser (and consequently cancel load of the background script) return
		/// true (1). Successful creation will be indicated by a call to
		/// cef_life_span_handler_t::OnAfterCreated, and
		/// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
		/// browser. See https://developer.chrome.com/extensions/event_pages for more
		/// information about extension background script usage.
		/// </summary>
		protected internal unsafe virtual bool OnBeforeBackgroundBrowser(CefExtension extension, string url, ref CefClient client, CefBrowserSettings settings)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int OnBeforeBackgroundBrowserDelegate(cef_extension_handler_t* self, cef_extension_t* extension, cef_string_t* url, cef_client_t** client, cef_browser_settings_t* settings);

#endif // NET_LESS_5_0
		// int (*)(_cef_extension_handler_t* self, _cef_extension_t* extension, const cef_string_t* url, _cef_client_t** client, _cef_browser_settings_t* settings)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int OnBeforeBackgroundBrowserImpl(cef_extension_handler_t* self, cef_extension_t* extension, cef_string_t* url, cef_client_t** client, cef_browser_settings_t* settings)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidOnBeforeBackgroundBrowser())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)extension);
				return default;
			}
			CefClient obj_client = CefClient.Wrap(CefClient.Create, *client);
			int rv = instance.OnBeforeBackgroundBrowser(CefExtension.Wrap(CefExtension.Create, extension), CefString.Read(url), ref obj_client, new CefBrowserSettings(settings)) ? 1 : 0;
			*client = (obj_client != null) ? obj_client.GetNativeInstance() : null;
			return rv;
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidOnBeforeBrowser();

		/// <summary>
		/// Called when an extension API (e.g. chrome.tabs.create) requests creation of
		/// a new browser. |extension| and |browser| are the source of the API call.
		/// |active_browser| may optionally be specified via the windowId property or
		/// returned via the get_active_browser() callback and provides the default
		/// |client| and |settings| values for the new browser. |index| is the position
		/// value optionally specified via the index property. |url| is the URL that
		/// will be loaded in the browser. |active| is true (1) if the new browser
		/// should be active when opened.  To allow creation of the browser optionally
		/// modify |windowInfo|, |client| and |settings| and return false (0). To
		/// cancel creation of the browser return true (1). Successful creation will be
		/// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
		/// modifications to |windowInfo| will be ignored if |active_browser| is
		/// wrapped in a cef_browser_view_t.
		/// </summary>
		protected internal unsafe virtual bool OnBeforeBrowser(CefExtension extension, CefBrowser browser, CefBrowser activeBrowser, int index, string url, bool active, CefWindowInfo windowInfo, ref CefClient client, CefBrowserSettings settings)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int OnBeforeBrowserDelegate(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, cef_browser_t* active_browser, int index, cef_string_t* url, int active, cef_window_info_t* windowInfo, cef_client_t** client, cef_browser_settings_t* settings);

#endif // NET_LESS_5_0
		// int (*)(_cef_extension_handler_t* self, _cef_extension_t* extension, _cef_browser_t* browser, _cef_browser_t* active_browser, int index, const cef_string_t* url, int active, _cef_window_info_t* windowInfo, _cef_client_t** client, _cef_browser_settings_t* settings)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int OnBeforeBrowserImpl(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, cef_browser_t* active_browser, int index, cef_string_t* url, int active, cef_window_info_t* windowInfo, cef_client_t** client, cef_browser_settings_t* settings)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidOnBeforeBrowser())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)extension);
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*)active_browser);
				return default;
			}
			CefClient obj_client = CefClient.Wrap(CefClient.Create, *client);
			int rv = instance.OnBeforeBrowser(CefExtension.Wrap(CefExtension.Create, extension), CefBrowser.Wrap(CefBrowser.Create, browser), CefBrowser.Wrap(CefBrowser.Create, active_browser), index, CefString.Read(url), active != 0, CefWindowInfo.Wrap(windowInfo), ref obj_client, new CefBrowserSettings(settings)) ? 1 : 0;
			*client = (obj_client != null) ? obj_client.GetNativeInstance() : null;
			return rv;
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidGetActiveBrowser();

		/// <summary>
		/// Called when no tabId is specified to an extension API call that accepts a
		/// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
		/// source of the API call. Return the browser that will be acted on by the API
		/// call or return NULL to act on |browser|. The returned browser must share
		/// the same cef_request_context_t as |browser|. Incognito browsers should not
		/// be considered unless the source extension has incognito access enabled, in
		/// which case |include_incognito| will be true (1).
		/// </summary>
		protected internal unsafe virtual CefBrowser GetActiveBrowser(CefExtension extension, CefBrowser browser, bool includeIncognito)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate cef_browser_t* GetActiveBrowserDelegate(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, int include_incognito);

#endif // NET_LESS_5_0
		// _cef_browser_t* (*)(_cef_extension_handler_t* self, _cef_extension_t* extension, _cef_browser_t* browser, int include_incognito)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe cef_browser_t* GetActiveBrowserImpl(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, int include_incognito)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidGetActiveBrowser())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)extension);
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				return default;
			}
			CefBrowser rv = instance.GetActiveBrowser(CefExtension.Wrap(CefExtension.Create, extension), CefBrowser.Wrap(CefBrowser.Create, browser), include_incognito != 0);
			if (rv == null)
				return null;
			return (rv != null) ? rv.GetNativeInstance() : null;
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidCanAccessBrowser();

		/// <summary>
		/// Called when the tabId associated with |target_browser| is specified to an
		/// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
		/// |extension| and |browser| are the source of the API call. Return true (1)
		/// to allow access of false (0) to deny access. Access to incognito browsers
		/// should not be allowed unless the source extension has incognito access
		/// enabled, in which case |include_incognito| will be true (1).
		/// </summary>
		protected internal unsafe virtual bool CanAccessBrowser(CefExtension extension, CefBrowser browser, bool includeIncognito, CefBrowser targetBrowser)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int CanAccessBrowserDelegate(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, int include_incognito, cef_browser_t* target_browser);

#endif // NET_LESS_5_0
		// int (*)(_cef_extension_handler_t* self, _cef_extension_t* extension, _cef_browser_t* browser, int include_incognito, _cef_browser_t* target_browser)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int CanAccessBrowserImpl(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, int include_incognito, cef_browser_t* target_browser)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidCanAccessBrowser())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)extension);
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*)target_browser);
				return default;
			}
			return instance.CanAccessBrowser(CefExtension.Wrap(CefExtension.Create, extension), CefBrowser.Wrap(CefBrowser.Create, browser), include_incognito != 0, CefBrowser.Wrap(CefBrowser.Create, target_browser)) ? 1 : 0;
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefExtensionHandlerPrivate.AvoidGetExtensionResource();

		/// <summary>
		/// Called to retrieve an extension resource that would normally be loaded from
		/// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
		/// |extension| and |browser| are the source of the resource request. |file| is
		/// the requested relative file path. To handle the resource request return
		/// true (1) and execute |callback| either synchronously or asynchronously. For
		/// the default behavior which reads the resource from the extension directory
		/// on disk return false (0). Localization substitutions will not be applied to
		/// resources handled via this function.
		/// </summary>
		protected internal unsafe virtual bool GetExtensionResource(CefExtension extension, CefBrowser browser, string file, CefGetExtensionResourceCallback callback)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int GetExtensionResourceDelegate(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, cef_string_t* file, cef_get_extension_resource_callback_t* callback);

#endif // NET_LESS_5_0
		// int (*)(_cef_extension_handler_t* self, _cef_extension_t* extension, _cef_browser_t* browser, const cef_string_t* file, _cef_get_extension_resource_callback_t* callback)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int GetExtensionResourceImpl(cef_extension_handler_t* self, cef_extension_t* extension, cef_browser_t* browser, cef_string_t* file, cef_get_extension_resource_callback_t* callback)
		{
			var instance = GetInstance((IntPtr)self) as CefExtensionHandler;
			if (instance == null || ((ICefExtensionHandlerPrivate)instance).AvoidGetExtensionResource())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)extension);
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*)callback);
				return default;
			}
			return instance.GetExtensionResource(CefExtension.Wrap(CefExtension.Create, extension), CefBrowser.Wrap(CefBrowser.Create, browser), CefString.Read(file), CefGetExtensionResourceCallback.Wrap(CefGetExtensionResourceCallback.Create, callback)) ? 1 : 0;
		}
	}
}
