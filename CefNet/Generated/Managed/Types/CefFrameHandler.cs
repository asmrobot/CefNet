// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_frame_handler_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Implement this structure to handle events related to cef_frame_t life span.
	/// The order of callbacks is:
	/// (1) During initial cef_browser_host_t creation and navigation of the main
	/// frame: - cef_frame_handler_t::OnFrameCreated =&gt; The initial main frame object
	/// has been
	/// created. Any commands will be queued until the frame is attached.
	/// - cef_frame_handler_t::OnMainFrameChanged =&gt; The initial main frame object
	/// has
	/// been assigned to the browser.
	/// - cef_life_span_handler_t::OnAfterCreated =&gt; The browser is now valid and can
	/// be
	/// used.
	/// - cef_frame_handler_t::OnFrameAttached =&gt; The initial main frame object is
	/// now
	/// connected to its peer in the renderer process. Commands can be routed.
	/// (2) During further cef_browser_host_t navigation/loading of the main frame
	/// and/or sub-frames: - cef_frame_handler_t::OnFrameCreated =&gt; A new main frame
	/// or sub-frame object has
	/// been created. Any commands will be queued until the frame is attached.
	/// - cef_frame_handler_t::OnFrameAttached =&gt; A new main frame or sub-frame
	/// object is
	/// now connected to its peer in the renderer process. Commands can be routed.
	/// - cef_frame_handler_t::OnFrameDetached =&gt; An existing main frame or sub-frame
	/// object has lost its connection to the renderer process. If multiple objects
	/// are detached at the same time then notifications will be sent for any
	/// sub-frame objects before the main frame object. Commands can no longer be
	/// routed and will be discarded.
	/// - cef_frame_handler_t::OnMainFrameChanged =&gt; A new main frame object has been
	/// assigned to the browser. This will only occur with cross-origin navigation
	/// or re-navigation after renderer process termination (due to crashes, etc).
	/// (3) During final cef_browser_host_t destruction of the main frame: -
	/// cef_frame_handler_t::OnFrameDetached =&gt; Any sub-frame objects have lost their
	/// connection to the renderer process. Commands can no longer be routed and
	/// will be discarded.
	/// - cef_life_span_handler_t::OnBeforeClose =&gt; The browser has been destroyed. -
	/// cef_frame_handler_t::OnFrameDetached =&gt; The main frame object have lost its
	/// connection to the renderer process. Notifications will be sent for any
	/// sub-frame objects before the main frame object. Commands can no longer be
	/// routed and will be discarded.
	/// - cef_frame_handler_t::OnMainFrameChanged =&gt; The final main frame object has
	/// been
	/// removed from the browser.
	/// Cross-origin navigation and/or loading receives special handling.
	/// When the main frame navigates to a different origin the OnMainFrameChanged
	/// callback (2) will be executed with the old and new main frame objects.
	/// When a new sub-frame is loaded in, or an existing sub-frame is navigated to,
	/// a different origin from the parent frame, a temporary sub-frame object will
	/// first be created in the parent&apos;s renderer process. That temporary sub-frame
	/// will then be discarded after the real cross-origin sub-frame is created in
	/// the new/target renderer process. The client will receive cross-origin
	/// navigation callbacks (2) for the transition from the temporary sub-frame to
	/// the real sub-frame. The temporary sub-frame will not recieve or execute
	/// commands during this transitional period (any sent commands will be
	/// discarded).
	/// When a new popup browser is created in a different origin from the parent
	/// browser, a temporary main frame object for the popup will first be created in
	/// the parent&apos;s renderer process. That temporary main frame will then be
	/// discarded after the real cross-origin main frame is created in the new/target
	/// renderer process. The client will recieve creation and initial navigation
	/// callbacks (1) for the temporary main frame, followed by cross-origin
	/// navigation callbacks (2) for the transition from the temporary main frame to
	/// the real main frame. The temporary main frame may receive and execute
	/// commands during this transitional period (any sent commands may be executed,
	/// but the behavior is potentially undesirable since they execute in the parent
	/// browser&apos;s renderer process and not the new/target renderer process).
	/// Callbacks will not be executed for placeholders that may be created during
	/// pre-commit navigation for sub-frames that do not yet exist in the renderer
	/// process. Placeholders will have cef_frame_t::get_identifier() == -4.
	/// The functions of this structure will be called on the UI thread unless
	/// otherwise indicated.
	/// </summary>
	/// <remarks>
	/// Role: Handler
	/// </remarks>
	public unsafe partial class CefFrameHandler : CefBaseRefCounted<cef_frame_handler_t>, ICefFrameHandlerPrivate
	{
#if NET_LESS_5_0
		private static readonly OnFrameCreatedDelegate fnOnFrameCreated = OnFrameCreatedImpl;

		private static readonly OnFrameAttachedDelegate fnOnFrameAttached = OnFrameAttachedImpl;

		private static readonly OnFrameDetachedDelegate fnOnFrameDetached = OnFrameDetachedImpl;

		private static readonly OnMainFrameChangedDelegate fnOnMainFrameChanged = OnMainFrameChangedImpl;

#endif // NET_LESS_5_0
		internal static unsafe CefFrameHandler Create(IntPtr instance)
		{
			return new CefFrameHandler((cef_frame_handler_t*)instance);
		}

		public CefFrameHandler()
		{
			cef_frame_handler_t* self = this.NativeInstance;
			#if NET_LESS_5_0
			self->on_frame_created = (void*)Marshal.GetFunctionPointerForDelegate(fnOnFrameCreated);
			self->on_frame_attached = (void*)Marshal.GetFunctionPointerForDelegate(fnOnFrameAttached);
			self->on_frame_detached = (void*)Marshal.GetFunctionPointerForDelegate(fnOnFrameDetached);
			self->on_main_frame_changed = (void*)Marshal.GetFunctionPointerForDelegate(fnOnMainFrameChanged);
			#else
			self->on_frame_created = (delegate* unmanaged[Stdcall]<cef_frame_handler_t*, cef_browser_t*, cef_frame_t*, void>)&OnFrameCreatedImpl;
			self->on_frame_attached = (delegate* unmanaged[Stdcall]<cef_frame_handler_t*, cef_browser_t*, cef_frame_t*, int, void>)&OnFrameAttachedImpl;
			self->on_frame_detached = (delegate* unmanaged[Stdcall]<cef_frame_handler_t*, cef_browser_t*, cef_frame_t*, void>)&OnFrameDetachedImpl;
			self->on_main_frame_changed = (delegate* unmanaged[Stdcall]<cef_frame_handler_t*, cef_browser_t*, cef_frame_t*, cef_frame_t*, void>)&OnMainFrameChangedImpl;
			#endif
		}

		public CefFrameHandler(cef_frame_handler_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefFrameHandlerPrivate.AvoidOnFrameCreated();

		/// <summary>
		/// Called when a new frame is created. This will be the first notification
		/// that references |frame|. Any commands that require transport to the
		/// associated renderer process (LoadRequest, SendProcessMessage, GetSource,
		/// etc.) will be queued until OnFrameAttached is called for |frame|.
		/// </summary>
		protected internal unsafe virtual void OnFrameCreated(CefBrowser browser, CefFrame frame)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnFrameCreatedDelegate(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* frame);

#endif // NET_LESS_5_0
		// void (*)(_cef_frame_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnFrameCreatedImpl(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* frame)
		{
			var instance = GetInstance((IntPtr)self) as CefFrameHandler;
			if (instance == null || ((ICefFrameHandlerPrivate)instance).AvoidOnFrameCreated())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*)frame);
				return;
			}
			instance.OnFrameCreated(CefBrowser.Wrap(CefBrowser.Create, browser), CefFrame.Wrap(CefFrame.Create, frame));
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefFrameHandlerPrivate.AvoidOnFrameAttached();

		/// <summary>
		/// Called when a frame can begin routing commands to/from the associated
		/// renderer process. |reattached| will be true (1) if the frame was re-
		/// attached after exiting the BackForwardCache. Any commands that were queued
		/// have now been dispatched.
		/// </summary>
		protected internal unsafe virtual void OnFrameAttached(CefBrowser browser, CefFrame frame, bool reattached)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnFrameAttachedDelegate(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, int reattached);

#endif // NET_LESS_5_0
		// void (*)(_cef_frame_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, int reattached)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnFrameAttachedImpl(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, int reattached)
		{
			var instance = GetInstance((IntPtr)self) as CefFrameHandler;
			if (instance == null || ((ICefFrameHandlerPrivate)instance).AvoidOnFrameAttached())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*)frame);
				return;
			}
			instance.OnFrameAttached(CefBrowser.Wrap(CefBrowser.Create, browser), CefFrame.Wrap(CefFrame.Create, frame), reattached != 0);
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefFrameHandlerPrivate.AvoidOnFrameDetached();

		/// <summary>
		/// Called when a frame loses its connection to the renderer process and will
		/// be destroyed. Any pending or future commands will be discarded and
		/// cef_frame_t::is_valid() will now return false (0) for |frame|. If called
		/// after cef_life_span_handler_t::on_before_close() during browser destruction
		/// then cef_browser_t::is_valid() will return false (0) for |browser|.
		/// </summary>
		protected internal unsafe virtual void OnFrameDetached(CefBrowser browser, CefFrame frame)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnFrameDetachedDelegate(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* frame);

#endif // NET_LESS_5_0
		// void (*)(_cef_frame_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnFrameDetachedImpl(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* frame)
		{
			var instance = GetInstance((IntPtr)self) as CefFrameHandler;
			if (instance == null || ((ICefFrameHandlerPrivate)instance).AvoidOnFrameDetached())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*)frame);
				return;
			}
			instance.OnFrameDetached(CefBrowser.Wrap(CefBrowser.Create, browser), CefFrame.Wrap(CefFrame.Create, frame));
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefFrameHandlerPrivate.AvoidOnMainFrameChanged();

		/// <summary>
		/// Called when the main frame changes due to (a) initial browser creation, (b)
		/// final browser destruction, (c) cross-origin navigation or (d) re-navigation
		/// after renderer process termination (due to crashes, etc). |old_frame| will
		/// be NULL and |new_frame| will be non-NULL when a main frame is assigned to
		/// |browser| for the first time. |old_frame| will be non-NULL and |new_frame|
		/// will be NULL and  when a main frame is removed from |browser| for the last
		/// time. Both |old_frame| and |new_frame| will be non-NULL for cross-origin
		/// navigations or re-navigation after renderer process termination. This
		/// function will be called after on_frame_created() for |new_frame| and/or
		/// after on_frame_detached() for |old_frame|. If called after
		/// cef_life_span_handler_t::on_before_close() during browser destruction then
		/// cef_browser_t::is_valid() will return false (0) for |browser|.
		/// </summary>
		protected internal unsafe virtual void OnMainFrameChanged(CefBrowser browser, CefFrame oldFrame, CefFrame newFrame)
		{
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate void OnMainFrameChangedDelegate(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* old_frame, cef_frame_t* new_frame);

#endif // NET_LESS_5_0
		// void (*)(_cef_frame_handler_t* self, _cef_browser_t* browser, _cef_frame_t* old_frame, _cef_frame_t* new_frame)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe void OnMainFrameChangedImpl(cef_frame_handler_t* self, cef_browser_t* browser, cef_frame_t* old_frame, cef_frame_t* new_frame)
		{
			var instance = GetInstance((IntPtr)self) as CefFrameHandler;
			if (instance == null || ((ICefFrameHandlerPrivate)instance).AvoidOnMainFrameChanged())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*)browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*)old_frame);
				ReleaseIfNonNull((cef_base_ref_counted_t*)new_frame);
				return;
			}
			instance.OnMainFrameChanged(CefBrowser.Wrap(CefBrowser.Create, browser), CefFrame.Wrap(CefFrame.Create, old_frame), CefFrame.Wrap(CefFrame.Create, new_frame));
		}
	}
}
