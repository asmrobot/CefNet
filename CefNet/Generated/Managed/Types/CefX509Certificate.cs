// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_x509certificate_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Structure representing a X.509 certificate.
	/// </summary>
	/// <remarks>
	/// Role: Proxy
	/// </remarks>
	public unsafe partial class CefX509Certificate : CefBaseRefCounted<cef_x509certificate_t>
	{
		internal static unsafe CefX509Certificate Create(IntPtr instance)
		{
			return new CefX509Certificate((cef_x509certificate_t*)instance);
		}

		public CefX509Certificate(cef_x509certificate_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		/// <summary>
		/// Gets the subject of the X.509 certificate. For HTTPS server certificates
		/// this represents the web server.  The common name of the subject should
		/// match the host name of the web server.
		/// </summary>
		public unsafe virtual CefX509CertPrincipal Subject
		{
			get
			{
				return SafeCall(CefX509CertPrincipal.Wrap(CefX509CertPrincipal.Create, NativeInstance->GetSubject()));
			}
		}

		/// <summary>
		/// Gets the issuer of the X.509 certificate.
		/// </summary>
		public unsafe virtual CefX509CertPrincipal Issuer
		{
			get
			{
				return SafeCall(CefX509CertPrincipal.Wrap(CefX509CertPrincipal.Create, NativeInstance->GetIssuer()));
			}
		}

		/// <summary>
		/// Gets the DER encoded serial number for the X.509 certificate. The value
		/// possibly includes a leading 00 byte.
		/// </summary>
		public unsafe virtual CefBinaryValue SerialNumber
		{
			get
			{
				return SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetSerialNumber()));
			}
		}

		/// <summary>
		/// Gets the date before which the X.509 certificate is invalid.
		/// CefTime.GetTimeT() will return 0 if no date was specified.
		/// </summary>
		public unsafe virtual CefTime ValidStart
		{
			get
			{
				return SafeCall(NativeInstance->GetValidStart());
			}
		}

		/// <summary>
		/// Gets the date after which the X.509 certificate is invalid.
		/// CefTime.GetTimeT() will return 0 if no date was specified.
		/// </summary>
		public unsafe virtual CefTime ValidExpiry
		{
			get
			{
				return SafeCall(NativeInstance->GetValidExpiry());
			}
		}

		/// <summary>
		/// Gets the DER encoded data for the X.509 certificate.
		/// </summary>
		public unsafe virtual CefBinaryValue DEREncoded
		{
			get
			{
				return SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetDEREncoded()));
			}
		}

		/// <summary>
		/// Gets the PEM encoded data for the X.509 certificate.
		/// </summary>
		public unsafe virtual CefBinaryValue PEMEncoded
		{
			get
			{
				return SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetPEMEncoded()));
			}
		}

		/// <summary>
		/// Gets the number of certificates in the issuer chain. If 0, the
		/// certificate is self-signed.
		/// </summary>
		public unsafe virtual long IssuerChainSize
		{
			get
			{
				return SafeCall((long)NativeInstance->GetIssuerChainSize());
			}
		}

		/// <summary>
		/// Returns the DER encoded data for the certificate issuer chain. If we failed
		/// to encode a certificate in the chain it is still present in the array but
		/// is an NULL string.
		/// </summary>
		public unsafe virtual void GetDEREncodedIssuerChain(ref long chainCount, ref CefBinaryValue[] chain)
		{
			
			var c1 = new UIntPtr((uint)chain.Length);
			cef_binary_value_t** arr1 = (cef_binary_value_t**)Marshal.AllocHGlobal(sizeof(cef_binary_value_t*) * chain.Length);
			for (int i = 0; i < chain.Length; i++)
			{
				var e1 = chain[i];
				*(arr1 + i) = e1 != null ? e1.GetNativeInstance() : null;
			}
			NativeInstance->GetDEREncodedIssuerChain(&c1, arr1);
			chainCount = (long)c1;
			for (int i = (int)c1; i >= 0; i--)
			{
				chain[i] = CefBinaryValue.Wrap(CefBinaryValue.Create, *(arr1 + i)); 
			}
			Marshal.FreeHGlobal((IntPtr)arr1);
			GC.KeepAlive(this);
		}

		/// <summary>
		/// Returns the PEM encoded data for the certificate issuer chain. If we failed
		/// to encode a certificate in the chain it is still present in the array but
		/// is an NULL string.
		/// </summary>
		public unsafe virtual void GetPEMEncodedIssuerChain(ref long chainCount, ref CefBinaryValue[] chain)
		{
			
			var c1 = new UIntPtr((uint)chain.Length);
			cef_binary_value_t** arr1 = (cef_binary_value_t**)Marshal.AllocHGlobal(sizeof(cef_binary_value_t*) * chain.Length);
			for (int i = 0; i < chain.Length; i++)
			{
				var e1 = chain[i];
				*(arr1 + i) = e1 != null ? e1.GetNativeInstance() : null;
			}
			NativeInstance->GetPEMEncodedIssuerChain(&c1, arr1);
			chainCount = (long)c1;
			for (int i = (int)c1; i >= 0; i--)
			{
				chain[i] = CefBinaryValue.Wrap(CefBinaryValue.Create, *(arr1 + i)); 
			}
			Marshal.FreeHGlobal((IntPtr)arr1);
			GC.KeepAlive(this);
		}
	}
}
