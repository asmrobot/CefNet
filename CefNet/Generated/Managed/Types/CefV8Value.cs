// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_v8value_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Structure representing a V8 value handle. V8 handles can only be accessed
	/// from the thread on which they are created. Valid threads for creating a V8
	/// handle include the render process main thread (TID_RENDERER) and WebWorker
	/// threads. A task runner for posting tasks on the associated thread can be
	/// retrieved via the cef_v8context_t::get_task_runner() function.
	/// </summary>
	/// <remarks>
	/// Role: Proxy
	/// </remarks>
	public unsafe partial class CefV8Value : CefBaseRefCounted<cef_v8value_t>
	{
		internal static unsafe CefV8Value Create(IntPtr instance)
		{
			return new CefV8Value((cef_v8value_t*)instance);
		}

		public CefV8Value(cef_v8value_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		/// <summary>
		/// Gets a value indicating whether the underlying handle is valid and it can be accessed
		/// on the current thread. Do not call any other functions if this property
		/// returns false.
		/// </summary>
		public unsafe virtual bool IsValid
		{
			get
			{
				return SafeCall(NativeInstance->IsValid() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is undefined.
		/// </summary>
		public unsafe virtual bool IsUndefined
		{
			get
			{
				return SafeCall(NativeInstance->IsUndefined() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is null.
		/// </summary>
		public unsafe virtual bool IsNull
		{
			get
			{
				return SafeCall(NativeInstance->IsNull() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is bool.
		/// </summary>
		public unsafe virtual bool IsBool
		{
			get
			{
				return SafeCall(NativeInstance->IsBool() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is int.
		/// </summary>
		public unsafe virtual bool IsInt
		{
			get
			{
				return SafeCall(NativeInstance->IsInt() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is unsigned int.
		/// </summary>
		public unsafe virtual bool IsUInt
		{
			get
			{
				return SafeCall(NativeInstance->IsUInt() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is double.
		/// </summary>
		public unsafe virtual bool IsDouble
		{
			get
			{
				return SafeCall(NativeInstance->IsDouble() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is Date.
		/// </summary>
		public unsafe virtual bool IsDate
		{
			get
			{
				return SafeCall(NativeInstance->IsDate() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is string.
		/// </summary>
		public unsafe virtual bool IsString
		{
			get
			{
				return SafeCall(NativeInstance->IsString() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is object.
		/// </summary>
		public unsafe virtual bool IsObject
		{
			get
			{
				return SafeCall(NativeInstance->IsObject() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is array.
		/// </summary>
		public unsafe virtual bool IsArray
		{
			get
			{
				return SafeCall(NativeInstance->IsArray() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is an ArrayBuffer.
		/// </summary>
		public unsafe virtual bool IsArrayBuffer
		{
			get
			{
				return SafeCall(NativeInstance->IsArrayBuffer() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the value type is function.
		/// </summary>
		public unsafe virtual bool IsFunction
		{
			get
			{
				return SafeCall(NativeInstance->IsFunction() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether this is a user created object.
		/// </summary>
		public unsafe virtual bool IsUserCreated
		{
			get
			{
				return SafeCall(NativeInstance->IsUserCreated() != 0);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the last function call resulted in an exception. This
		/// attribute exists only in the scope of the current CEF value object.
		/// </summary>
		public unsafe virtual bool HasException
		{
			get
			{
				return SafeCall(NativeInstance->HasException() != 0);
			}
		}

		/// <summary>
		/// Returns true (1) if this object is pointing to the same handle as |that|
		/// object.
		/// </summary>
		public unsafe virtual bool IsSame(CefV8Value that)
		{
			return SafeCall(NativeInstance->IsSame((that != null) ? that.GetNativeInstance() : null) != 0);
		}

		/// <summary>
		/// Return a bool value.
		/// </summary>
		public unsafe virtual bool GetBoolValue()
		{
			return SafeCall(NativeInstance->GetBoolValue() != 0);
		}

		/// <summary>
		/// Return an int value.
		/// </summary>
		public unsafe virtual int GetIntValue()
		{
			return SafeCall(NativeInstance->GetIntValue());
		}

		/// <summary>
		/// Return an unsigned int value.
		/// </summary>
		public unsafe virtual uint GetUIntValue()
		{
			return SafeCall(NativeInstance->GetUIntValue());
		}

		/// <summary>
		/// Return a double value.
		/// </summary>
		public unsafe virtual double GetDoubleValue()
		{
			return SafeCall(NativeInstance->GetDoubleValue());
		}

		/// <summary>
		/// Return a Date value.
		/// </summary>
		public unsafe virtual CefTime GetDateValue()
		{
			return SafeCall(NativeInstance->GetDateValue());
		}

		/// <summary>
		/// Return a string value.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		public unsafe virtual string GetStringValue()
		{
			return SafeCall(CefString.ReadAndFree(NativeInstance->GetStringValue()));
		}

		/// <summary>
		/// Returns the exception resulting from the last function call. This attribute
		/// exists only in the scope of the current CEF value object.
		/// </summary>
		public unsafe virtual CefV8Exception GetException()
		{
			return SafeCall(CefV8Exception.Wrap(CefV8Exception.Create, NativeInstance->GetException()));
		}

		/// <summary>
		/// Clears the last exception and returns true (1) on success.
		/// </summary>
		public unsafe virtual bool ClearException()
		{
			return SafeCall(NativeInstance->ClearException() != 0);
		}

		/// <summary>
		/// Returns true (1) if this object will re-throw future exceptions. This
		/// attribute exists only in the scope of the current CEF value object.
		/// </summary>
		public unsafe virtual bool WillRethrowExceptions()
		{
			return SafeCall(NativeInstance->WillRethrowExceptions() != 0);
		}

		/// <summary>
		/// Set whether this object will re-throw future exceptions. By default
		/// exceptions are not re-thrown. If a exception is re-thrown the current
		/// context should not be accessed again until after the exception has been
		/// caught and not re-thrown. Returns true (1) on success. This attribute
		/// exists only in the scope of the current CEF value object.
		/// </summary>
		public unsafe virtual bool SetRethrowExceptions(bool rethrow)
		{
			return SafeCall(NativeInstance->SetRethrowExceptions(rethrow ? 1 : 0) != 0);
		}

		/// <summary>
		/// Returns true (1) if the object has a value with the specified identifier.
		/// </summary>
		public unsafe virtual bool HasValueByKey(string key)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = key != null ? key.Length : 0 };
				return SafeCall(NativeInstance->HasValueByKey(&cstr0) != 0);
			}
		}

		/// <summary>
		/// Returns true (1) if the object has a value with the specified identifier.
		/// </summary>
		public unsafe virtual bool HasValueByIndex(int index)
		{
			return SafeCall(NativeInstance->HasValueByIndex(index) != 0);
		}

		/// <summary>
		/// Deletes the value with the specified identifier and returns true (1) on
		/// success. Returns false (0) if this function is called incorrectly or an
		/// exception is thrown. For read-only and don&apos;t-delete values this function
		/// will return true (1) even though deletion failed.
		/// </summary>
		public unsafe virtual bool DeleteValueByKey(string key)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = key != null ? key.Length : 0 };
				return SafeCall(NativeInstance->DeleteValueByKey(&cstr0) != 0);
			}
		}

		/// <summary>
		/// Deletes the value with the specified identifier and returns true (1) on
		/// success. Returns false (0) if this function is called incorrectly, deletion
		/// fails or an exception is thrown. For read-only and don&apos;t-delete values this
		/// function will return true (1) even though deletion failed.
		/// </summary>
		public unsafe virtual bool DeleteValueByIndex(int index)
		{
			return SafeCall(NativeInstance->DeleteValueByIndex(index) != 0);
		}

		/// <summary>
		/// Returns the value with the specified identifier on success. Returns NULL if
		/// this function is called incorrectly or an exception is thrown.
		/// </summary>
		public unsafe virtual CefV8Value GetValueByKey(string key)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = key != null ? key.Length : 0 };
				return SafeCall(CefV8Value.Wrap(CefV8Value.Create, NativeInstance->GetValueByKey(&cstr0)));
			}
		}

		/// <summary>
		/// Returns the value with the specified identifier on success. Returns NULL if
		/// this function is called incorrectly or an exception is thrown.
		/// </summary>
		public unsafe virtual CefV8Value GetValueByIndex(int index)
		{
			return SafeCall(CefV8Value.Wrap(CefV8Value.Create, NativeInstance->GetValueByIndex(index)));
		}

		/// <summary>
		/// Associates a value with the specified identifier and returns true (1) on
		/// success. Returns false (0) if this function is called incorrectly or an
		/// exception is thrown. For read-only values this function will return true
		/// (1) even though assignment failed.
		/// </summary>
		public unsafe virtual bool SetValueByKey(string key, CefV8Value value, CefV8PropertyAttribute attribute)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = key != null ? key.Length : 0 };
				return SafeCall(NativeInstance->SetValueByKey(&cstr0, (value != null) ? value.GetNativeInstance() : null, attribute) != 0);
			}
		}

		/// <summary>
		/// Associates a value with the specified identifier and returns true (1) on
		/// success. Returns false (0) if this function is called incorrectly or an
		/// exception is thrown. For read-only values this function will return true
		/// (1) even though assignment failed.
		/// </summary>
		public unsafe virtual bool SetValueByIndex(int index, CefV8Value value)
		{
			return SafeCall(NativeInstance->SetValueByIndex(index, (value != null) ? value.GetNativeInstance() : null) != 0);
		}

		/// <summary>
		/// Registers an identifier and returns true (1) on success. Access to the
		/// identifier will be forwarded to the cef_v8accessor_t instance passed to
		/// cef_v8value_t::cef_v8value_create_object(). Returns false (0) if this
		/// function is called incorrectly or an exception is thrown. For read-only
		/// values this function will return true (1) even though assignment failed.
		/// </summary>
		public unsafe virtual bool SetValueByAccessor(string key, CefV8AccessControl settings, CefV8PropertyAttribute attribute)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = key != null ? key.Length : 0 };
				return SafeCall(NativeInstance->SetValueByAccessor(&cstr0, settings, attribute) != 0);
			}
		}

		/// <summary>
		/// Read the keys for the object&apos;s values into the specified vector. Integer-
		/// based keys will also be returned as strings.
		/// </summary>
		public unsafe virtual int GetKeys(CefStringList keys)
		{
			return SafeCall(NativeInstance->GetKeys(keys.GetNativeInstance()));
		}

		/// <summary>
		/// Sets the user data for this object and returns true (1) on success. Returns
		/// false (0) if this function is called incorrectly. This function can only be
		/// called on user created objects.
		/// </summary>
		public unsafe virtual bool SetUserData(CefBaseRefCounted userData)
		{
			return SafeCall(NativeInstance->SetUserData(userData.GetNativeInstance()) != 0);
		}

		/// <summary>
		/// Returns the user data, if any, assigned to this object.
		/// </summary>
		public unsafe virtual CefBaseRefCounted GetUserData()
		{
			return SafeCall(UnknownRefCounted.Wrap(UnknownRefCounted.Create, NativeInstance->GetUserData()));
		}

		/// <summary>
		/// Returns the amount of externally allocated memory registered for the
		/// object.
		/// </summary>
		public unsafe virtual int GetExternallyAllocatedMemory()
		{
			return SafeCall(NativeInstance->GetExternallyAllocatedMemory());
		}

		/// <summary>
		/// Adjusts the amount of registered external memory for the object. Used to
		/// give V8 an indication of the amount of externally allocated memory that is
		/// kept alive by JavaScript objects. V8 uses this information to decide when
		/// to perform global garbage collection. Each cef_v8value_t tracks the amount
		/// of external memory associated with it and automatically decreases the
		/// global total by the appropriate amount on its destruction.
		/// |change_in_bytes| specifies the number of bytes to adjust by. This function
		/// returns the number of bytes associated with the object after the
		/// adjustment. This function can only be called on user created objects.
		/// </summary>
		public unsafe virtual int AdjustExternallyAllocatedMemory(int changeInBytes)
		{
			return SafeCall(NativeInstance->AdjustExternallyAllocatedMemory(changeInBytes));
		}

		/// <summary>
		/// Returns the number of elements in the array.
		/// </summary>
		public unsafe virtual int GetArrayLength()
		{
			return SafeCall(NativeInstance->GetArrayLength());
		}

		/// <summary>
		/// Returns the ReleaseCallback object associated with the ArrayBuffer or NULL
		/// if the ArrayBuffer was not created with CreateArrayBuffer.
		/// </summary>
		public unsafe virtual CefV8ArrayBufferReleaseCallback GetArrayBufferReleaseCallback()
		{
			return SafeCall(CefV8ArrayBufferReleaseCallback.Wrap(CefV8ArrayBufferReleaseCallback.Create, NativeInstance->GetArrayBufferReleaseCallback()));
		}

		/// <summary>
		/// Prevent the ArrayBuffer from using it&apos;s memory block by setting the length
		/// to zero. This operation cannot be undone. If the ArrayBuffer was created
		/// with CreateArrayBuffer then
		/// cef_v8array_buffer_release_callback_t::ReleaseBuffer will be called to
		/// release the underlying buffer.
		/// </summary>
		public unsafe virtual int NeuterArrayBuffer()
		{
			return SafeCall(NativeInstance->NeuterArrayBuffer());
		}

		/// <summary>
		/// Returns the function name.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		public unsafe virtual string GetFunctionName()
		{
			return SafeCall(CefString.ReadAndFree(NativeInstance->GetFunctionName()));
		}

		/// <summary>
		/// Returns the function handler or NULL if not a CEF-created function.
		/// </summary>
		public unsafe virtual CefV8Handler GetFunctionHandler()
		{
			return SafeCall(CefV8Handler.Wrap(CefV8Handler.Create, NativeInstance->GetFunctionHandler()));
		}

		/// <summary>
		/// Execute the function using the current V8 context. This function should
		/// only be called from within the scope of a cef_v8handler_t or
		/// cef_v8accessor_t callback, or in combination with calling enter() and
		/// exit() on a stored cef_v8context_t reference. |object| is the receiver
		/// (&apos;this&apos; object) of the function. If |object| is NULL the current context&apos;s
		/// global object will be used. |arguments| is the list of arguments that will
		/// be passed to the function. Returns the function return value on success.
		/// Returns NULL if this function is called incorrectly or an exception is
		/// thrown.
		/// </summary>
		public unsafe virtual CefV8Value ExecuteFunction(CefV8Value @object, CefV8Value[] arguments)
		{
			
			cef_v8value_t** arr2 = (cef_v8value_t**)Marshal.AllocHGlobal(sizeof(cef_v8value_t*) * arguments.Length);
			for (int i = 0; i < arguments.Length; i++)
			{
				var e2 = arguments[i];
				*(arr2 + i) = e2 != null ? e2.GetNativeInstance() : null;
			}
			var rv = CefV8Value.Wrap(CefV8Value.Create, NativeInstance->ExecuteFunction((@object != null) ? @object.GetNativeInstance() : null, new UIntPtr((uint)arguments.Length), arr2));
			Marshal.FreeHGlobal((IntPtr)arr2);
			GC.KeepAlive(this);
			return rv;
		}

		/// <summary>
		/// Execute the function using the specified V8 context. |object| is the
		/// receiver (&apos;this&apos; object) of the function. If |object| is NULL the specified
		/// context&apos;s global object will be used. |arguments| is the list of arguments
		/// that will be passed to the function. Returns the function return value on
		/// success. Returns NULL if this function is called incorrectly or an
		/// exception is thrown.
		/// </summary>
		public unsafe virtual CefV8Value ExecuteFunctionWithContext(CefV8Context context, CefV8Value @object, CefV8Value[] arguments)
		{
			
			cef_v8value_t** arr3 = (cef_v8value_t**)Marshal.AllocHGlobal(sizeof(cef_v8value_t*) * arguments.Length);
			for (int i = 0; i < arguments.Length; i++)
			{
				var e3 = arguments[i];
				*(arr3 + i) = e3 != null ? e3.GetNativeInstance() : null;
			}
			var rv = CefV8Value.Wrap(CefV8Value.Create, NativeInstance->ExecuteFunctionWithContext((context != null) ? context.GetNativeInstance() : null, (@object != null) ? @object.GetNativeInstance() : null, new UIntPtr((uint)arguments.Length), arr3));
			Marshal.FreeHGlobal((IntPtr)arr3);
			GC.KeepAlive(this);
			return rv;
		}
	}
}
