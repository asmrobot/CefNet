// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_v8context_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Structure representing a V8 context handle. V8 handles can only be accessed
	/// from the thread on which they are created. Valid threads for creating a V8
	/// handle include the render process main thread (TID_RENDERER) and WebWorker
	/// threads. A task runner for posting tasks on the associated thread can be
	/// retrieved via the cef_v8context_t::get_task_runner() function.
	/// </summary>
	/// <remarks>
	/// Role: Proxy
	/// </remarks>
	public unsafe partial class CefV8Context : CefBaseRefCounted<cef_v8context_t>
	{
		internal static unsafe CefV8Context Create(IntPtr instance)
		{
			return new CefV8Context((cef_v8context_t*)instance);
		}

		public CefV8Context(cef_v8context_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		/// <summary>
		/// Gets the task runner associated with this context. V8 handles can only
		/// be accessed from the thread on which they are created. This property can be
		/// called on any render process thread.
		/// </summary>
		public unsafe virtual CefTaskRunner TaskRunner
		{
			get
			{
				return SafeCall(CefTaskRunner.Wrap(CefTaskRunner.Create, NativeInstance->GetTaskRunner()));
			}
		}

		/// <summary>
		/// Gets a value indicating whether the underlying handle is valid and it can be accessed
		/// on the current thread. Do not call any other functions if this property
		/// returns false.
		/// </summary>
		public unsafe virtual bool IsValid
		{
			get
			{
				return SafeCall(NativeInstance->IsValid() != 0);
			}
		}

		/// <summary>
		/// Gets the browser for this context. This property will return an NULL
		/// reference for WebWorker contexts.
		/// </summary>
		public unsafe virtual CefBrowser Browser
		{
			get
			{
				return SafeCall(CefBrowser.Wrap(CefBrowser.Create, NativeInstance->GetBrowser()));
			}
		}

		/// <summary>
		/// Gets the frame for this context. This property will return an NULL
		/// reference for WebWorker contexts.
		/// </summary>
		public unsafe virtual CefFrame Frame
		{
			get
			{
				return SafeCall(CefFrame.Wrap(CefFrame.Create, NativeInstance->GetFrame()));
			}
		}

		/// <summary>
		/// Returns the global object for this context. The context must be entered
		/// before calling this function.
		/// </summary>
		public unsafe virtual CefV8Value GetGlobal()
		{
			return SafeCall(CefV8Value.Wrap(CefV8Value.Create, NativeInstance->GetGlobal()));
		}

		/// <summary>
		/// Enter this context. A context must be explicitly entered before creating a
		/// V8 Object, Array, Function or Date asynchronously. exit() must be called
		/// the same number of times as enter() before releasing this context. V8
		/// objects belong to the context in which they are created. Returns true (1)
		/// if the scope was entered successfully.
		/// </summary>
		public unsafe virtual bool Enter()
		{
			return SafeCall(NativeInstance->Enter() != 0);
		}

		/// <summary>
		/// Exit this context. Call this function only after calling enter(). Returns
		/// true (1) if the scope was exited successfully.
		/// </summary>
		public unsafe virtual bool Exit()
		{
			return SafeCall(NativeInstance->Exit() != 0);
		}

		/// <summary>
		/// Returns true (1) if this object is pointing to the same handle as |that|
		/// object.
		/// </summary>
		public unsafe virtual bool IsSame(CefV8Context that)
		{
			return SafeCall(NativeInstance->IsSame((that != null) ? that.GetNativeInstance() : null) != 0);
		}

		/// <summary>
		/// Execute a string of JavaScript code in this V8 context. The |script_url|
		/// parameter is the URL where the script in question can be found, if any. The
		/// |start_line| parameter is the base line number to use for error reporting.
		/// On success |retval| will be set to the return value, if any, and the
		/// function will return true (1). On failure |exception| will be set to the
		/// exception, if any, and the function will return false (0).
		/// </summary>
		public unsafe virtual bool Eval(string code, string scriptUrl, int startLine, ref CefV8Value retval, ref CefV8Exception exception)
		{
			fixed (char* s0 = code)
			fixed (char* s1 = scriptUrl)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = code != null ? code.Length : 0 };
				var cstr1 = new cef_string_t { Str = s1, Length = scriptUrl != null ? scriptUrl.Length : 0 };
				cef_v8value_t* p3 = (retval != null) ? retval.GetNativeInstance() : null;
				cef_v8value_t** pp3 = &p3;
				cef_v8exception_t* p4 = (exception != null) ? exception.GetNativeInstance() : null;
				cef_v8exception_t** pp4 = &p4;
				var rv = NativeInstance->Eval(&cstr0, &cstr1, startLine, pp3, pp4) != 0;
				retval = CefV8Value.Wrap(CefV8Value.Create, p3);
				exception = CefV8Exception.Wrap(CefV8Exception.Create, p4);
				GC.KeepAlive(this);
				return rv;
			}
		}
	}
}
