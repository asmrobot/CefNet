// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_resource_bundle_handler_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Structure used to implement a custom resource bundle structure. See
	/// CefSettings for additional options related to resource bundle loading. The
	/// functions of this structure may be called on multiple threads.
	/// </summary>
	/// <remarks>
	/// Role: Handler
	/// </remarks>
	public unsafe partial class CefResourceBundleHandler : CefBaseRefCounted<cef_resource_bundle_handler_t>, ICefResourceBundleHandlerPrivate
	{
#if NET_LESS_5_0
		private static readonly GetLocalizedStringDelegate fnGetLocalizedString = GetLocalizedStringImpl;

		private static readonly GetDataResourceDelegate fnGetDataResource = GetDataResourceImpl;

		private static readonly GetDataResourceForScaleDelegate fnGetDataResourceForScale = GetDataResourceForScaleImpl;

#endif // NET_LESS_5_0
		internal static unsafe CefResourceBundleHandler Create(IntPtr instance)
		{
			return new CefResourceBundleHandler((cef_resource_bundle_handler_t*)instance);
		}

		public CefResourceBundleHandler()
		{
			cef_resource_bundle_handler_t* self = this.NativeInstance;
			#if NET_LESS_5_0
			self->get_localized_string = (void*)Marshal.GetFunctionPointerForDelegate(fnGetLocalizedString);
			self->get_data_resource = (void*)Marshal.GetFunctionPointerForDelegate(fnGetDataResource);
			self->get_data_resource_for_scale = (void*)Marshal.GetFunctionPointerForDelegate(fnGetDataResourceForScale);
			#else
			self->get_localized_string = (delegate* unmanaged[Stdcall]<cef_resource_bundle_handler_t*, int, cef_string_t*, int>)&GetLocalizedStringImpl;
			self->get_data_resource = (delegate* unmanaged[Stdcall]<cef_resource_bundle_handler_t*, int, void**, UIntPtr*, int>)&GetDataResourceImpl;
			self->get_data_resource_for_scale = (delegate* unmanaged[Stdcall]<cef_resource_bundle_handler_t*, int, CefScaleFactor, void**, UIntPtr*, int>)&GetDataResourceForScaleImpl;
			#endif
		}

		public CefResourceBundleHandler(cef_resource_bundle_handler_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefResourceBundleHandlerPrivate.AvoidGetLocalizedString();

		/// <summary>
		/// Called to retrieve a localized translation for the specified |string_id|.
		/// To provide the translation set |string| to the translation string and
		/// return true (1). To use the default translation return false (0). Include
		/// cef_pack_strings.h for a listing of valid string ID values.
		/// </summary>
		protected internal unsafe virtual bool GetLocalizedString(int stringId, ref string @string)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int GetLocalizedStringDelegate(cef_resource_bundle_handler_t* self, int string_id, cef_string_t* @string);

#endif // NET_LESS_5_0
		// int (*)(_cef_resource_bundle_handler_t* self, int string_id, cef_string_t* string)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int GetLocalizedStringImpl(cef_resource_bundle_handler_t* self, int string_id, cef_string_t* @string)
		{
			var instance = GetInstance((IntPtr)self) as CefResourceBundleHandler;
			if (instance == null || ((ICefResourceBundleHandlerPrivate)instance).AvoidGetLocalizedString())
			{
				return default;
			}
			string s_string = CefString.Read(@string);
			string s_orig_string = s_string;
			int rv = instance.GetLocalizedString(string_id, ref s_string) ? 1 : 0;
			if (s_string != s_orig_string)
				CefString.Replace(@string, s_string);
			return rv;
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefResourceBundleHandlerPrivate.AvoidGetDataResource();

		/// <summary>
		/// Called to retrieve data for the specified scale independent |resource_id|.
		/// To provide the resource data set |data| and |data_size| to the data pointer
		/// and size respectively and return true (1). To use the default resource data
		/// return false (0). The resource data will not be copied and must remain
		/// resident in memory. Include cef_pack_resources.h for a listing of valid
		/// resource ID values.
		/// </summary>
		protected internal unsafe virtual bool GetDataResource(int resourceId, ref IntPtr data, ref long dataSize)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int GetDataResourceDelegate(cef_resource_bundle_handler_t* self, int resource_id, void** data, UIntPtr* data_size);

#endif // NET_LESS_5_0
		// int (*)(_cef_resource_bundle_handler_t* self, int resource_id, void** data, size_t* data_size)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int GetDataResourceImpl(cef_resource_bundle_handler_t* self, int resource_id, void** data, UIntPtr* data_size)
		{
			var instance = GetInstance((IntPtr)self) as CefResourceBundleHandler;
			if (instance == null || ((ICefResourceBundleHandlerPrivate)instance).AvoidGetDataResource())
			{
				return default;
			}
			long c3 = (long)(*data_size);
			int rv = instance.GetDataResource(resource_id, ref *(IntPtr*)data, ref c3) ? 1 : 0;
			*data_size = new UIntPtr((ulong)c3);
			return rv;
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefResourceBundleHandlerPrivate.AvoidGetDataResourceForScale();

		/// <summary>
		/// Called to retrieve data for the specified |resource_id| nearest the scale
		/// factor |scale_factor|. To provide the resource data set |data| and
		/// |data_size| to the data pointer and size respectively and return true (1).
		/// To use the default resource data return false (0). The resource data will
		/// not be copied and must remain resident in memory. Include
		/// cef_pack_resources.h for a listing of valid resource ID values.
		/// </summary>
		protected internal unsafe virtual bool GetDataResourceForScale(int resourceId, CefScaleFactor scaleFactor, ref IntPtr data, ref long dataSize)
		{
			return default;
		}

#if NET_LESS_5_0
		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private unsafe delegate int GetDataResourceForScaleDelegate(cef_resource_bundle_handler_t* self, int resource_id, CefScaleFactor scale_factor, void** data, UIntPtr* data_size);

#endif // NET_LESS_5_0
		// int (*)(_cef_resource_bundle_handler_t* self, int resource_id, cef_scale_factor_t scale_factor, void** data, size_t* data_size)*
#if !NET_LESS_5_0
		[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
		private static unsafe int GetDataResourceForScaleImpl(cef_resource_bundle_handler_t* self, int resource_id, CefScaleFactor scale_factor, void** data, UIntPtr* data_size)
		{
			var instance = GetInstance((IntPtr)self) as CefResourceBundleHandler;
			if (instance == null || ((ICefResourceBundleHandlerPrivate)instance).AvoidGetDataResourceForScale())
			{
				return default;
			}
			long c4 = (long)(*data_size);
			int rv = instance.GetDataResourceForScale(resource_id, scale_factor, ref *(IntPtr*)data, ref c4) ? 1 : 0;
			*data_size = new UIntPtr((ulong)c4);
			return rv;
		}
	}
}
