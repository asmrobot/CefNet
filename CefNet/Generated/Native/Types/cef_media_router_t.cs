// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_media_router_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Supports discovery of and communication with media devices on the local
	/// network via the Cast and DIAL protocols. The functions of this structure may
	/// be called on any browser process thread unless otherwise indicated.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_media_router_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// _cef_registration_t* (*)(_cef_media_router_t* self, _cef_media_observer_t* observer)*
		/// </summary>
		public void* add_observer;

		/// <summary>
		/// Add an observer for MediaRouter events. The observer will remain registered
		/// until the returned Registration object is destroyed.
		/// </summary>
		[NativeName("add_observer")]
		public unsafe cef_registration_t* AddObserver(cef_media_observer_t* observer)
		{
			fixed (cef_media_router_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_media_router_t*, cef_media_observer_t*, cef_registration_t*>)add_observer)(self, observer);
			}
		}

		/// <summary>
		/// _cef_media_source_t* (*)(_cef_media_router_t* self, const cef_string_t* urn)*
		/// </summary>
		public void* get_source;

		/// <summary>
		/// Returns a MediaSource object for the specified media source URN. Supported
		/// URN schemes include &quot;cast:&quot; and &quot;dial:&quot;, and will be already known by the
		/// client application (e.g. &quot;cast:
		/// &lt;appId
		/// &gt;?clientId=
		/// &lt;clientId
		/// &gt;&quot;).
		/// </summary>
		[NativeName("get_source")]
		public unsafe cef_media_source_t* GetSource([Immutable]cef_string_t* urn)
		{
			fixed (cef_media_router_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_media_router_t*, cef_string_t*, cef_media_source_t*>)get_source)(self, urn);
			}
		}

		/// <summary>
		/// void (*)(_cef_media_router_t* self)*
		/// </summary>
		public void* notify_current_sinks;

		/// <summary>
		/// Trigger an asynchronous call to cef_media_observer_t::OnSinks on all
		/// registered observers.
		/// </summary>
		[NativeName("notify_current_sinks")]
		public unsafe void NotifyCurrentSinks()
		{
			fixed (cef_media_router_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_media_router_t*, void>)notify_current_sinks)(self);
			}
		}

		/// <summary>
		/// void (*)(_cef_media_router_t* self, _cef_media_source_t* source, _cef_media_sink_t* sink, _cef_media_route_create_callback_t* callback)*
		/// </summary>
		public void* create_route;

		/// <summary>
		/// Create a new route between |source| and |sink|. Source and sink must be
		/// valid, compatible (as reported by cef_media_sink_t::IsCompatibleWith), and
		/// a route between them must not already exist. |callback| will be executed on
		/// success or failure. If route creation succeeds it will also trigger an
		/// asynchronous call to cef_media_observer_t::OnRoutes on all registered
		/// observers.
		/// </summary>
		[NativeName("create_route")]
		public unsafe void CreateRoute(cef_media_source_t* source, cef_media_sink_t* sink, cef_media_route_create_callback_t* callback)
		{
			fixed (cef_media_router_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_media_router_t*, cef_media_source_t*, cef_media_sink_t*, cef_media_route_create_callback_t*, void>)create_route)(self, source, sink, callback);
			}
		}

		/// <summary>
		/// void (*)(_cef_media_router_t* self)*
		/// </summary>
		public void* notify_current_routes;

		/// <summary>
		/// Trigger an asynchronous call to cef_media_observer_t::OnRoutes on all
		/// registered observers.
		/// </summary>
		[NativeName("notify_current_routes")]
		public unsafe void NotifyCurrentRoutes()
		{
			fixed (cef_media_router_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_media_router_t*, void>)notify_current_routes)(self);
			}
		}
	}
}

