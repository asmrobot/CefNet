// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_urlrequest_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Structure that should be implemented by the cef_urlrequest_t client. The
	/// functions of this structure will be called on the same thread that created
	/// the request unless otherwise documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_urlrequest_client_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// void (*)(_cef_urlrequest_client_t* self, _cef_urlrequest_t* request)*
		/// </summary>
		public void* on_request_complete;

		/// <summary>
		/// Notifies the client that the request has completed. Use the
		/// cef_urlrequest_t::GetRequestStatus function to determine if the request was
		/// successful or not.
		/// </summary>
		[NativeName("on_request_complete")]
		public unsafe void OnRequestComplete(cef_urlrequest_t* request)
		{
			fixed (cef_urlrequest_client_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_urlrequest_client_t*, cef_urlrequest_t*, void>)on_request_complete)(self, request);
			}
		}

		/// <summary>
		/// void (*)(_cef_urlrequest_client_t* self, _cef_urlrequest_t* request, int64 current, int64 total)*
		/// </summary>
		public void* on_upload_progress;

		/// <summary>
		/// Notifies the client of upload progress. |current| denotes the number of
		/// bytes sent so far and |total| is the total size of uploading data (or -1 if
		/// chunked upload is enabled). This function will only be called if the
		/// UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request.
		/// </summary>
		[NativeName("on_upload_progress")]
		public unsafe void OnUploadProgress(cef_urlrequest_t* request, long current, long total)
		{
			fixed (cef_urlrequest_client_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_urlrequest_client_t*, cef_urlrequest_t*, long, long, void>)on_upload_progress)(self, request, current, total);
			}
		}

		/// <summary>
		/// void (*)(_cef_urlrequest_client_t* self, _cef_urlrequest_t* request, int64 current, int64 total)*
		/// </summary>
		public void* on_download_progress;

		/// <summary>
		/// Notifies the client of download progress. |current| denotes the number of
		/// bytes received up to the call and |total| is the expected total size of the
		/// response (or -1 if not determined).
		/// </summary>
		[NativeName("on_download_progress")]
		public unsafe void OnDownloadProgress(cef_urlrequest_t* request, long current, long total)
		{
			fixed (cef_urlrequest_client_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_urlrequest_client_t*, cef_urlrequest_t*, long, long, void>)on_download_progress)(self, request, current, total);
			}
		}

		/// <summary>
		/// void (*)(_cef_urlrequest_client_t* self, _cef_urlrequest_t* request, const void* data, size_t data_length)*
		/// </summary>
		public void* on_download_data;

		/// <summary>
		/// Called when some part of the response is read. |data| contains the current
		/// bytes received since the last call. This function will not be called if the
		/// UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request.
		/// </summary>
		[NativeName("on_download_data")]
		public unsafe void OnDownloadData(cef_urlrequest_t* request, [Immutable]void* data, UIntPtr data_length)
		{
			fixed (cef_urlrequest_client_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_urlrequest_client_t*, cef_urlrequest_t*, void*, UIntPtr, void>)on_download_data)(self, request, data, data_length);
			}
		}

		/// <summary>
		/// int (*)(_cef_urlrequest_client_t* self, int isProxy, const cef_string_t* host, int port, const cef_string_t* realm, const cef_string_t* scheme, _cef_auth_callback_t* callback)*
		/// </summary>
		public void* get_auth_credentials;

		/// <summary>
		/// Called on the IO thread when the browser needs credentials from the user.
		/// |isProxy| indicates whether the host is a proxy server. |host| contains the
		/// hostname and |port| contains the port number. Return true (1) to continue
		/// the request and call cef_auth_callback_t::cont() when the authentication
		/// information is available. If the request has an associated browser/frame
		/// then returning false (0) will result in a call to GetAuthCredentials on the
		/// cef_request_handler_t associated with that browser, if any. Otherwise,
		/// returning false (0) will cancel the request immediately. This function will
		/// only be called for requests initiated from the browser process.
		/// </summary>
		[NativeName("get_auth_credentials")]
		public unsafe int GetAuthCredentials(int isProxy, [Immutable]cef_string_t* host, int port, [Immutable]cef_string_t* realm, [Immutable]cef_string_t* scheme, cef_auth_callback_t* callback)
		{
			fixed (cef_urlrequest_client_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_urlrequest_client_t*, int, cef_string_t*, int, cef_string_t*, cef_string_t*, cef_auth_callback_t*, int>)get_auth_credentials)(self, isProxy, host, port, realm, scheme, callback);
			}
		}
	}
}

