// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_render_handler_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Implement this structure to handle events when window rendering is disabled.
	/// The functions of this structure will be called on the UI thread.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_render_handler_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// _cef_accessibility_handler_t* (*)(_cef_render_handler_t* self)*
		/// </summary>
		public void* get_accessibility_handler;

		/// <summary>
		/// Return the handler for accessibility notifications. If no handler is
		/// provided the default implementation will be used.
		/// </summary>
		[NativeName("get_accessibility_handler")]
		public unsafe cef_accessibility_handler_t* GetAccessibilityHandler()
		{
			fixed (cef_render_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_accessibility_handler_t*>)get_accessibility_handler)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_render_handler_t* self, _cef_browser_t* browser, cef_rect_t* rect)*
		/// </summary>
		public void* get_root_screen_rect;

		/// <summary>
		/// Called to retrieve the root window rectangle in screen coordinates. Return
		/// true (1) if the rectangle was provided. If this function returns false (0)
		/// the rectangle from GetViewRect will be used.
		/// </summary>
		[NativeName("get_root_screen_rect")]
		public unsafe int GetRootScreenRect(cef_browser_t* browser, cef_rect_t* rect)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, cef_rect_t*, int>)get_root_screen_rect)(self, browser, rect);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, cef_rect_t* rect)*
		/// </summary>
		public void* get_view_rect;

		/// <summary>
		/// Called to retrieve the view rectangle which is relative to screen
		/// coordinates. This function must always provide a non-NULL rectangle.
		/// </summary>
		[NativeName("get_view_rect")]
		public unsafe void GetViewRect(cef_browser_t* browser, cef_rect_t* rect)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, cef_rect_t*, void>)get_view_rect)(self, browser, rect);
			}
		}

		/// <summary>
		/// int (*)(_cef_render_handler_t* self, _cef_browser_t* browser, int viewX, int viewY, int* screenX, int* screenY)*
		/// </summary>
		public void* get_screen_point;

		/// <summary>
		/// Called to retrieve the translation from view coordinates to actual screen
		/// coordinates. Return true (1) if the screen coordinates were provided.
		/// </summary>
		[NativeName("get_screen_point")]
		public unsafe int GetScreenPoint(cef_browser_t* browser, int viewX, int viewY, int* screenX, int* screenY)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, int, int, int*, int*, int>)get_screen_point)(self, browser, viewX, viewY, screenX, screenY);
			}
		}

		/// <summary>
		/// int (*)(_cef_render_handler_t* self, _cef_browser_t* browser, _cef_screen_info_t* screen_info)*
		/// </summary>
		public void* get_screen_info;

		/// <summary>
		/// Called to allow the client to fill in the CefScreenInfo object with
		/// appropriate values. Return true (1) if the |screen_info| structure has been
		/// modified.
		/// If the screen info rectangle is left NULL the rectangle from GetViewRect
		/// will be used. If the rectangle is still NULL or invalid popups may not be
		/// drawn correctly.
		/// </summary>
		[NativeName("get_screen_info")]
		public unsafe int GetScreenInfo(cef_browser_t* browser, cef_screen_info_t* screen_info)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, cef_screen_info_t*, int>)get_screen_info)(self, browser, screen_info);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, int show)*
		/// </summary>
		public void* on_popup_show;

		/// <summary>
		/// Called when the browser wants to show or hide the popup widget. The popup
		/// should be shown if |show| is true (1) and hidden if |show| is false (0).
		/// </summary>
		[NativeName("on_popup_show")]
		public unsafe void OnPopupShow(cef_browser_t* browser, int show)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, int, void>)on_popup_show)(self, browser, show);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, const cef_rect_t* rect)*
		/// </summary>
		public void* on_popup_size;

		/// <summary>
		/// Called when the browser wants to move or resize the popup widget. |rect|
		/// contains the new location and size in view coordinates.
		/// </summary>
		[NativeName("on_popup_size")]
		public unsafe void OnPopupSize(cef_browser_t* browser, [Immutable]cef_rect_t* rect)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, cef_rect_t*, void>)on_popup_size)(self, browser, rect);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, cef_paint_element_type_t type, size_t dirtyRectsCount, const cef_rect_t* dirtyRects, const void* buffer, int width, int height)*
		/// </summary>
		public void* on_paint;

		/// <summary>
		/// Called when an element should be painted. Pixel values passed to this
		/// function are scaled relative to view coordinates based on the value of
		/// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
		/// indicates whether the element is the view or the popup widget. |buffer|
		/// contains the pixel data for the whole image. |dirtyRects| contains the set
		/// of rectangles in pixel coordinates that need to be repainted. |buffer| will
		/// be |width|*|height|*4 bytes in size and represents a BGRA image with an
		/// upper-left origin. This function is only called when
		/// cef_window_tInfo::shared_texture_enabled is set to false (0).
		/// </summary>
		[NativeName("on_paint")]
		public unsafe void OnPaint(cef_browser_t* browser, CefPaintElementType type, UIntPtr dirtyRectsCount, [Immutable]cef_rect_t* dirtyRects, [Immutable]void* buffer, int width, int height)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, CefPaintElementType, UIntPtr, cef_rect_t*, void*, int, int, void>)on_paint)(self, browser, type, dirtyRectsCount, dirtyRects, buffer, width, height);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, cef_paint_element_type_t type, size_t dirtyRectsCount, const cef_rect_t* dirtyRects, void* shared_handle)*
		/// </summary>
		public void* on_accelerated_paint;

		/// <summary>
		/// Called when an element has been rendered to the shared texture handle.
		/// |type| indicates whether the element is the view or the popup widget.
		/// |dirtyRects| contains the set of rectangles in pixel coordinates that need
		/// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
		/// can be accessed via ID3D11Device using the OpenSharedResource function.
		/// This function is only called when cef_window_tInfo::shared_texture_enabled
		/// is set to true (1), and is currently only supported on Windows.
		/// </summary>
		[NativeName("on_accelerated_paint")]
		public unsafe void OnAcceleratedPaint(cef_browser_t* browser, CefPaintElementType type, UIntPtr dirtyRectsCount, [Immutable]cef_rect_t* dirtyRects, void* shared_handle)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, CefPaintElementType, UIntPtr, cef_rect_t*, void*, void>)on_accelerated_paint)(self, browser, type, dirtyRectsCount, dirtyRects, shared_handle);
			}
		}

		/// <summary>
		/// int (*)(_cef_render_handler_t* self, _cef_browser_t* browser, _cef_drag_data_t* drag_data, cef_drag_operations_mask_t allowed_ops, int x, int y)*
		/// </summary>
		public void* start_dragging;

		/// <summary>
		/// Called when the user starts dragging content in the web view. Contextual
		/// information about the dragged content is supplied by |drag_data|. (|x|,
		/// |y|) is the drag start location in screen coordinates. OS APIs that run a
		/// system message loop may be used within the StartDragging call.
		/// Return false (0) to abort the drag operation. Don&apos;t call any of
		/// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
		/// Return true (1) to handle the drag operation. Call
		/// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
		/// synchronously or asynchronously to inform the web view that the drag
		/// operation has ended.
		/// </summary>
		[NativeName("start_dragging")]
		public unsafe int StartDragging(cef_browser_t* browser, cef_drag_data_t* drag_data, CefDragOperationsMask allowed_ops, int x, int y)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, cef_drag_data_t*, CefDragOperationsMask, int, int, int>)start_dragging)(self, browser, drag_data, allowed_ops, x, y);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, cef_drag_operations_mask_t operation)*
		/// </summary>
		public void* update_drag_cursor;

		/// <summary>
		/// Called when the web view wants to update the mouse cursor during a drag 
		/// &amp;
		/// drop operation. |operation| describes the allowed operation (none, move,
		/// copy, link).
		/// </summary>
		[NativeName("update_drag_cursor")]
		public unsafe void UpdateDragCursor(cef_browser_t* browser, CefDragOperationsMask operation)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, CefDragOperationsMask, void>)update_drag_cursor)(self, browser, operation);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, double x, double y)*
		/// </summary>
		public void* on_scroll_offset_changed;

		/// <summary>
		/// Called when the scroll offset has changed.
		/// </summary>
		[NativeName("on_scroll_offset_changed")]
		public unsafe void OnScrollOffsetChanged(cef_browser_t* browser, double x, double y)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, double, double, void>)on_scroll_offset_changed)(self, browser, x, y);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, const cef_range_t* selected_range, size_t character_boundsCount, const cef_rect_t* character_bounds)*
		/// </summary>
		public void* on_ime_composition_range_changed;

		/// <summary>
		/// Called when the IME composition range has changed. |selected_range| is the
		/// range of characters that have been selected. |character_bounds| is the
		/// bounds of each character in view coordinates.
		/// </summary>
		[NativeName("on_ime_composition_range_changed")]
		public unsafe void OnImeCompositionRangeChanged(cef_browser_t* browser, [Immutable]cef_range_t* selected_range, UIntPtr character_boundsCount, [Immutable]cef_rect_t* character_bounds)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, cef_range_t*, UIntPtr, cef_rect_t*, void>)on_ime_composition_range_changed)(self, browser, selected_range, character_boundsCount, character_bounds);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, const cef_string_t* selected_text, const cef_range_t* selected_range)*
		/// </summary>
		public void* on_text_selection_changed;

		/// <summary>
		/// Called when text selection has changed for the specified |browser|.
		/// |selected_text| is the currently selected text and |selected_range| is the
		/// character range.
		/// </summary>
		[NativeName("on_text_selection_changed")]
		public unsafe void OnTextSelectionChanged(cef_browser_t* browser, [Immutable]cef_string_t* selected_text, [Immutable]cef_range_t* selected_range)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, cef_string_t*, cef_range_t*, void>)on_text_selection_changed)(self, browser, selected_text, selected_range);
			}
		}

		/// <summary>
		/// void (*)(_cef_render_handler_t* self, _cef_browser_t* browser, cef_text_input_mode_t input_mode)*
		/// </summary>
		public void* on_virtual_keyboard_requested;

		/// <summary>
		/// Called when an on-screen keyboard should be shown or hidden for the
		/// specified |browser|. |input_mode| specifies what kind of keyboard should be
		/// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
		/// for this browser should be hidden.
		/// </summary>
		[NativeName("on_virtual_keyboard_requested")]
		public unsafe void OnVirtualKeyboardRequested(cef_browser_t* browser, CefTextInputMode input_mode)
		{
			fixed (cef_render_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_render_handler_t*, cef_browser_t*, CefTextInputMode, void>)on_virtual_keyboard_requested)(self, browser, input_mode);
			}
		}
	}
}

