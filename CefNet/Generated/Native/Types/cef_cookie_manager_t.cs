// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_cookie_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Structure used for managing cookies. The functions of this structure may be
	/// called on any thread unless otherwise indicated.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_cookie_manager_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// int (*)(_cef_cookie_manager_t* self, _cef_cookie_visitor_t* visitor)*
		/// </summary>
		public void* visit_all_cookies;

		/// <summary>
		/// Visit all cookies on the UI thread. The returned cookies are ordered by
		/// longest path, then by earliest creation date. Returns false (0) if cookies
		/// cannot be accessed.
		/// </summary>
		[NativeName("visit_all_cookies")]
		public unsafe int VisitAllCookies(cef_cookie_visitor_t* visitor)
		{
			fixed (cef_cookie_manager_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_cookie_manager_t*, cef_cookie_visitor_t*, int>)visit_all_cookies)(self, visitor);
			}
		}

		/// <summary>
		/// int (*)(_cef_cookie_manager_t* self, const cef_string_t* url, int includeHttpOnly, _cef_cookie_visitor_t* visitor)*
		/// </summary>
		public void* visit_url_cookies;

		/// <summary>
		/// Visit a subset of cookies on the UI thread. The results are filtered by the
		/// given url scheme, host, domain and path. If |includeHttpOnly| is true (1)
		/// HTTP-only cookies will also be included in the results. The returned
		/// cookies are ordered by longest path, then by earliest creation date.
		/// Returns false (0) if cookies cannot be accessed.
		/// </summary>
		[NativeName("visit_url_cookies")]
		public unsafe int VisitUrlCookies([Immutable]cef_string_t* url, int includeHttpOnly, cef_cookie_visitor_t* visitor)
		{
			fixed (cef_cookie_manager_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_cookie_manager_t*, cef_string_t*, int, cef_cookie_visitor_t*, int>)visit_url_cookies)(self, url, includeHttpOnly, visitor);
			}
		}

		/// <summary>
		/// int (*)(_cef_cookie_manager_t* self, const cef_string_t* url, const const _cef_cookie_t* cookie, _cef_set_cookie_callback_t* callback)*
		/// </summary>
		public void* set_cookie;

		/// <summary>
		/// Sets a cookie given a valid URL and explicit user-provided cookie
		/// attributes. This function expects each attribute to be well-formed. It will
		/// check for disallowed characters (e.g. the &apos;;&apos; character is disallowed
		/// within the cookie value attribute) and fail without setting the cookie if
		/// such characters are found. If |callback| is non-NULL it will be executed
		/// asnychronously on the UI thread after the cookie has been set. Returns
		/// false (0) if an invalid URL is specified or if cookies cannot be accessed.
		/// </summary>
		[NativeName("set_cookie")]
		public unsafe int SetCookie([Immutable]cef_string_t* url, [Immutable]cef_cookie_t* cookie, cef_set_cookie_callback_t* callback)
		{
			fixed (cef_cookie_manager_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_cookie_manager_t*, cef_string_t*, cef_cookie_t*, cef_set_cookie_callback_t*, int>)set_cookie)(self, url, cookie, callback);
			}
		}

		/// <summary>
		/// int (*)(_cef_cookie_manager_t* self, const cef_string_t* url, const cef_string_t* cookie_name, _cef_delete_cookies_callback_t* callback)*
		/// </summary>
		public void* delete_cookies;

		/// <summary>
		/// Delete all cookies that match the specified parameters. If both |url| and
		/// |cookie_name| values are specified all host and domain cookies matching
		/// both will be deleted. If only |url| is specified all host cookies (but not
		/// domain cookies) irrespective of path will be deleted. If |url| is NULL all
		/// cookies for all hosts and domains will be deleted. If |callback| is non-
		/// NULL it will be executed asnychronously on the UI thread after the cookies
		/// have been deleted. Returns false (0) if a non-NULL invalid URL is specified
		/// or if cookies cannot be accessed. Cookies can alternately be deleted using
		/// the Visit*Cookies() functions.
		/// </summary>
		[NativeName("delete_cookies")]
		public unsafe int DeleteCookies([Immutable]cef_string_t* url, [Immutable]cef_string_t* cookie_name, cef_delete_cookies_callback_t* callback)
		{
			fixed (cef_cookie_manager_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_cookie_manager_t*, cef_string_t*, cef_string_t*, cef_delete_cookies_callback_t*, int>)delete_cookies)(self, url, cookie_name, callback);
			}
		}

		/// <summary>
		/// int (*)(_cef_cookie_manager_t* self, _cef_completion_callback_t* callback)*
		/// </summary>
		public void* flush_store;

		/// <summary>
		/// Flush the backing store (if any) to disk. If |callback| is non-NULL it will
		/// be executed asnychronously on the UI thread after the flush is complete.
		/// Returns false (0) if cookies cannot be accessed.
		/// </summary>
		[NativeName("flush_store")]
		public unsafe int FlushStore(cef_completion_callback_t* callback)
		{
			fixed (cef_cookie_manager_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_cookie_manager_t*, cef_completion_callback_t*, int>)flush_store)(self, callback);
			}
		}
	}
}

