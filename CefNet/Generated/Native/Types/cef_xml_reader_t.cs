// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_xml_reader_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Structure that supports the reading of XML data via the libxml streaming API.
	/// The functions of this structure should only be called on the thread that
	/// creates the object.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_xml_reader_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* move_to_next_node;

		/// <summary>
		/// Moves the cursor to the next node in the document. This function must be
		/// called at least once to set the current cursor position. Returns true (1)
		/// if the cursor position was set successfully.
		/// </summary>
		[NativeName("move_to_next_node")]
		public unsafe int MoveToNextNode()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)move_to_next_node)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* close;

		/// <summary>
		/// Close the document. This should be called directly to ensure that cleanup
		/// occurs on the correct thread.
		/// </summary>
		[NativeName("close")]
		public unsafe int Close()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)close)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* has_error;

		/// <summary>
		/// Returns true (1) if an error has been reported by the XML parser.
		/// </summary>
		[NativeName("has_error")]
		public unsafe int HasError()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)has_error)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_error;

		/// <summary>
		/// Returns the error string.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_error")]
		public unsafe cef_string_userfree_t GetError()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_error)(self);
			}
		}

		/// <summary>
		/// cef_xml_node_type_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_type;

		/// <summary>
		/// Returns the node type.
		/// </summary>
		[NativeName("get_type")]
		public unsafe CefXmlNodeType GetCefType()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, CefXmlNodeType>)get_type)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_depth;

		/// <summary>
		/// Returns the node depth. Depth starts at 0 for the root node.
		/// </summary>
		[NativeName("get_depth")]
		public unsafe int GetDepth()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)get_depth)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_local_name;

		/// <summary>
		/// Returns the local name. See http://www.w3.org/TR/REC-xml-names/#NT-
		/// LocalPart for additional details.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_local_name")]
		public unsafe cef_string_userfree_t GetLocalName()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_local_name)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_prefix;

		/// <summary>
		/// Returns the namespace prefix. See http://www.w3.org/TR/REC-xml-names/ for
		/// additional details.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_prefix")]
		public unsafe cef_string_userfree_t GetPrefix()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_prefix)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_qualified_name;

		/// <summary>
		/// Returns the qualified name, equal to (Prefix:)LocalName. See
		/// http://www.w3.org/TR/REC-xml-names/#ns-qualnames for additional details.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_qualified_name")]
		public unsafe cef_string_userfree_t GetQualifiedName()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_qualified_name)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_namespace_uri;

		/// <summary>
		/// Returns the URI defining the namespace associated with the node. See
		/// http://www.w3.org/TR/REC-xml-names/ for additional details.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_namespace_uri")]
		public unsafe cef_string_userfree_t GetNamespaceUri()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_namespace_uri)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_base_uri;

		/// <summary>
		/// Returns the base URI of the node. See http://www.w3.org/TR/xmlbase/ for
		/// additional details.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_base_uri")]
		public unsafe cef_string_userfree_t GetBaseUri()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_base_uri)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_xml_lang;

		/// <summary>
		/// Returns the xml:lang scope within which the node resides. See
		/// http://www.w3.org/TR/REC-xml/#sec-lang-tag for additional details.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_xml_lang")]
		public unsafe cef_string_userfree_t GetXmlLang()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_xml_lang)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* is_empty_element;

		/// <summary>
		/// Returns true (1) if the node represents an NULL element. &lt;a /&gt;is considered
		/// NULL but &lt;a&gt;&lt;/a&gt;is not.
		/// </summary>
		[NativeName("is_empty_element")]
		public unsafe int IsEmptyElement()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)is_empty_element)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* has_value;

		/// <summary>
		/// Returns true (1) if the node has a text value.
		/// </summary>
		[NativeName("has_value")]
		public unsafe int HasValue()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)has_value)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_value;

		/// <summary>
		/// Returns the text value.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_value")]
		public unsafe cef_string_userfree_t GetValue()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_value)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* has_attributes;

		/// <summary>
		/// Returns true (1) if the node has attributes.
		/// </summary>
		[NativeName("has_attributes")]
		public unsafe int HasAttributes()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)has_attributes)(self);
			}
		}

		/// <summary>
		/// size_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_attribute_count;

		/// <summary>
		/// Returns the number of attributes.
		/// </summary>
		[NativeName("get_attribute_count")]
		public unsafe UIntPtr GetAttributeCount()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, UIntPtr>)get_attribute_count)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self, int index)*
		/// </summary>
		public void* get_attribute_byindex;

		/// <summary>
		/// Returns the value of the attribute at the specified 0-based index.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_attribute_byindex")]
		public unsafe cef_string_userfree_t GetAttributeByIndex(int index)
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int, cef_string_userfree_t>)get_attribute_byindex)(self, index);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self, const cef_string_t* qualifiedName)*
		/// </summary>
		public void* get_attribute_byqname;

		/// <summary>
		/// Returns the value of the attribute with the specified qualified name.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_attribute_byqname")]
		public unsafe cef_string_userfree_t GetAttributeByQName([Immutable]cef_string_t* qualifiedName)
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_t*, cef_string_userfree_t>)get_attribute_byqname)(self, qualifiedName);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self, const cef_string_t* localName, const cef_string_t* namespaceURI)*
		/// </summary>
		public void* get_attribute_bylname;

		/// <summary>
		/// Returns the value of the attribute with the specified local name and
		/// namespace URI.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_attribute_bylname")]
		public unsafe cef_string_userfree_t GetAttributeByLName([Immutable]cef_string_t* localName, [Immutable]cef_string_t* namespaceURI)
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_t*, cef_string_t*, cef_string_userfree_t>)get_attribute_bylname)(self, localName, namespaceURI);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_inner_xml;

		/// <summary>
		/// Returns an XML representation of the current node&apos;s children.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_inner_xml")]
		public unsafe cef_string_userfree_t GetInnerXml()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_inner_xml)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_outer_xml;

		/// <summary>
		/// Returns an XML representation of the current node including its children.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_outer_xml")]
		public unsafe cef_string_userfree_t GetOuterXml()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_userfree_t>)get_outer_xml)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* get_line_number;

		/// <summary>
		/// Returns the line number for the current node.
		/// </summary>
		[NativeName("get_line_number")]
		public unsafe int GetLineNumber()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)get_line_number)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self, int index)*
		/// </summary>
		public void* move_to_attribute_byindex;

		/// <summary>
		/// Moves the cursor to the attribute at the specified 0-based index. Returns
		/// true (1) if the cursor position was set successfully.
		/// </summary>
		[NativeName("move_to_attribute_byindex")]
		public unsafe int MoveToAttributeByIndex(int index)
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int, int>)move_to_attribute_byindex)(self, index);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self, const cef_string_t* qualifiedName)*
		/// </summary>
		public void* move_to_attribute_byqname;

		/// <summary>
		/// Moves the cursor to the attribute with the specified qualified name.
		/// Returns true (1) if the cursor position was set successfully.
		/// </summary>
		[NativeName("move_to_attribute_byqname")]
		public unsafe int MoveToAttributeByQName([Immutable]cef_string_t* qualifiedName)
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_t*, int>)move_to_attribute_byqname)(self, qualifiedName);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self, const cef_string_t* localName, const cef_string_t* namespaceURI)*
		/// </summary>
		public void* move_to_attribute_bylname;

		/// <summary>
		/// Moves the cursor to the attribute with the specified local name and
		/// namespace URI. Returns true (1) if the cursor position was set
		/// successfully.
		/// </summary>
		[NativeName("move_to_attribute_bylname")]
		public unsafe int MoveToAttributeByLName([Immutable]cef_string_t* localName, [Immutable]cef_string_t* namespaceURI)
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, cef_string_t*, cef_string_t*, int>)move_to_attribute_bylname)(self, localName, namespaceURI);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* move_to_first_attribute;

		/// <summary>
		/// Moves the cursor to the first attribute in the current element. Returns
		/// true (1) if the cursor position was set successfully.
		/// </summary>
		[NativeName("move_to_first_attribute")]
		public unsafe int MoveToFirstAttribute()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)move_to_first_attribute)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* move_to_next_attribute;

		/// <summary>
		/// Moves the cursor to the next attribute in the current element. Returns true
		/// (1) if the cursor position was set successfully.
		/// </summary>
		[NativeName("move_to_next_attribute")]
		public unsafe int MoveToNextAttribute()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)move_to_next_attribute)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_xml_reader_t* self)*
		/// </summary>
		public void* move_to_carrying_element;

		/// <summary>
		/// Moves the cursor back to the carrying element. Returns true (1) if the
		/// cursor position was set successfully.
		/// </summary>
		[NativeName("move_to_carrying_element")]
		public unsafe int MoveToCarryingElement()
		{
			fixed (cef_xml_reader_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_xml_reader_t*, int>)move_to_carrying_element)(self);
			}
		}
	}
}

