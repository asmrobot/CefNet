// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_request_handler_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Implement this structure to handle events related to browser requests. The
	/// functions of this structure will be called on the thread indicated.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_request_handler_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// int (*)(_cef_request_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, _cef_request_t* request, int user_gesture, int is_redirect)*
		/// </summary>
		public void* on_before_browse;

		/// <summary>
		/// Called on the UI thread before browser navigation. Return true (1) to
		/// cancel the navigation or false (0) to allow the navigation to proceed. The
		/// |request| object cannot be modified in this callback.
		/// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
		/// If the navigation is allowed cef_load_handler_t::OnLoadStart and
		/// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
		/// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
		/// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
		/// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
		/// it navigated automatically (e.g. via the DomContentLoaded event).
		/// </summary>
		[NativeName("on_before_browse")]
		public unsafe int OnBeforeBrowse(cef_browser_t* browser, cef_frame_t* frame, cef_request_t* request, int user_gesture, int is_redirect)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, cef_frame_t*, cef_request_t*, int, int, int>)on_before_browse)(self, browser, frame, request, user_gesture, is_redirect);
			}
		}

		/// <summary>
		/// int (*)(_cef_request_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, const cef_string_t* target_url, cef_window_open_disposition_t target_disposition, int user_gesture)*
		/// </summary>
		public void* on_open_urlfrom_tab;

		/// <summary>
		/// Called on the UI thread before OnBeforeBrowse in certain limited cases
		/// where navigating a new or different browser might be desirable. This
		/// includes user-initiated navigation that might open in a special way (e.g.
		/// links clicked via middle-click or ctrl + left-click) and certain types of
		/// cross-origin navigation initiated from the renderer process (e.g.
		/// navigating the top-level frame to/from a file URL). The |browser| and
		/// |frame| values represent the source of the navigation. The
		/// |target_disposition| value indicates where the user intended to navigate
		/// the browser based on standard Chromium behaviors (e.g. current tab, new
		/// tab, etc). The |user_gesture| value will be true (1) if the browser
		/// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
		/// it navigated automatically (e.g. via the DomContentLoaded event). Return
		/// true (1) to cancel the navigation or false (0) to allow the navigation to
		/// proceed in the source browser&apos;s top-level frame.
		/// </summary>
		[NativeName("on_open_urlfrom_tab")]
		public unsafe int OnOpenUrlFromTab(cef_browser_t* browser, cef_frame_t* frame, [Immutable]cef_string_t* target_url, CefWindowOpenDisposition target_disposition, int user_gesture)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, cef_frame_t*, cef_string_t*, CefWindowOpenDisposition, int, int>)on_open_urlfrom_tab)(self, browser, frame, target_url, target_disposition, user_gesture);
			}
		}

		/// <summary>
		/// _cef_resource_request_handler_t* (*)(_cef_request_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, _cef_request_t* request, int is_navigation, int is_download, const cef_string_t* request_initiator, int* disable_default_handling)*
		/// </summary>
		public void* get_resource_request_handler;

		/// <summary>
		/// Called on the browser process IO thread before a resource request is
		/// initiated. The |browser| and |frame| values represent the source of the
		/// request. |request| represents the request contents and cannot be modified
		/// in this callback. |is_navigation| will be true (1) if the resource request
		/// is a navigation. |is_download| will be true (1) if the resource request is
		/// a download. |request_initiator| is the origin (scheme + domain) of the page
		/// that initiated the request. Set |disable_default_handling| to true (1) to
		/// disable default handling of the request, in which case it will need to be
		/// handled via cef_resource_request_handler_t::GetResourceHandler or it will
		/// be canceled. To allow the resource load to proceed with default handling
		/// return NULL. To specify a handler for the resource return a
		/// cef_resource_request_handler_t object. If this callback returns NULL the
		/// same function will be called on the associated
		/// cef_request_context_handler_t, if any.
		/// </summary>
		[NativeName("get_resource_request_handler")]
		public unsafe cef_resource_request_handler_t* GetResourceRequestHandler(cef_browser_t* browser, cef_frame_t* frame, cef_request_t* request, int is_navigation, int is_download, [Immutable]cef_string_t* request_initiator, int* disable_default_handling)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, cef_frame_t*, cef_request_t*, int, int, cef_string_t*, int*, cef_resource_request_handler_t*>)get_resource_request_handler)(self, browser, frame, request, is_navigation, is_download, request_initiator, disable_default_handling);
			}
		}

		/// <summary>
		/// int (*)(_cef_request_handler_t* self, _cef_browser_t* browser, const cef_string_t* origin_url, int isProxy, const cef_string_t* host, int port, const cef_string_t* realm, const cef_string_t* scheme, _cef_auth_callback_t* callback)*
		/// </summary>
		public void* get_auth_credentials;

		/// <summary>
		/// Called on the IO thread when the browser needs credentials from the user.
		/// |origin_url| is the origin making this authentication request. |isProxy|
		/// indicates whether the host is a proxy server. |host| contains the hostname
		/// and |port| contains the port number. |realm| is the realm of the challenge
		/// and may be NULL. |scheme| is the authentication scheme used, such as
		/// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
		/// FTP server. Return true (1) to continue the request and call
		/// cef_auth_callback_t::cont() either in this function or at a later time when
		/// the authentication information is available. Return false (0) to cancel the
		/// request immediately.
		/// </summary>
		[NativeName("get_auth_credentials")]
		public unsafe int GetAuthCredentials(cef_browser_t* browser, [Immutable]cef_string_t* origin_url, int isProxy, [Immutable]cef_string_t* host, int port, [Immutable]cef_string_t* realm, [Immutable]cef_string_t* scheme, cef_auth_callback_t* callback)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, cef_string_t*, int, cef_string_t*, int, cef_string_t*, cef_string_t*, cef_auth_callback_t*, int>)get_auth_credentials)(self, browser, origin_url, isProxy, host, port, realm, scheme, callback);
			}
		}

		/// <summary>
		/// int (*)(_cef_request_handler_t* self, _cef_browser_t* browser, const cef_string_t* origin_url, int64 new_size, _cef_callback_t* callback)*
		/// </summary>
		public void* on_quota_request;

		/// <summary>
		/// Called on the IO thread when JavaScript requests a specific storage quota
		/// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
		/// origin of the page making the request. |new_size| is the requested quota
		/// size in bytes. Return true (1) to continue the request and call
		/// cef_callback_t functions either in this function or at a later time to
		/// grant or deny the request. Return false (0) to cancel the request
		/// immediately.
		/// </summary>
		[NativeName("on_quota_request")]
		public unsafe int OnQuotaRequest(cef_browser_t* browser, [Immutable]cef_string_t* origin_url, long new_size, cef_callback_t* callback)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, cef_string_t*, long, cef_callback_t*, int>)on_quota_request)(self, browser, origin_url, new_size, callback);
			}
		}

		/// <summary>
		/// int (*)(_cef_request_handler_t* self, _cef_browser_t* browser, cef_errorcode_t cert_error, const cef_string_t* request_url, _cef_sslinfo_t* ssl_info, _cef_callback_t* callback)*
		/// </summary>
		public void* on_certificate_error;

		/// <summary>
		/// Called on the UI thread to handle requests for URLs with an invalid SSL
		/// certificate. Return true (1) and call cef_callback_t functions either in
		/// this function or at a later time to continue or cancel the request. Return
		/// false (0) to cancel the request immediately. If
		/// CefSettings.ignore_certificate_errors is set all invalid certificates will
		/// be accepted without calling this function.
		/// </summary>
		[NativeName("on_certificate_error")]
		public unsafe int OnCertificateError(cef_browser_t* browser, CefErrorCode cert_error, [Immutable]cef_string_t* request_url, cef_sslinfo_t* ssl_info, cef_callback_t* callback)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, CefErrorCode, cef_string_t*, cef_sslinfo_t*, cef_callback_t*, int>)on_certificate_error)(self, browser, cert_error, request_url, ssl_info, callback);
			}
		}

		/// <summary>
		/// int (*)(_cef_request_handler_t* self, _cef_browser_t* browser, int isProxy, const cef_string_t* host, int port, size_t certificatesCount, const _cef_x509certificate_t** certificates, _cef_select_client_certificate_callback_t* callback)*
		/// </summary>
		public void* on_select_client_certificate;

		/// <summary>
		/// Called on the UI thread when a client certificate is being requested for
		/// authentication. Return false (0) to use the default behavior and
		/// automatically select the first certificate available. Return true (1) and
		/// call cef_select_client_certificate_callback_t::Select either in this
		/// function or at a later time to select a certificate. Do not call Select or
		/// call it with NULL to continue without using any certificate. |isProxy|
		/// indicates whether the host is an HTTPS proxy or the origin server. |host|
		/// and |port| contains the hostname and port of the SSL server. |certificates|
		/// is the list of certificates to choose from; this list has already been
		/// pruned by Chromium so that it only contains certificates from issuers that
		/// the server trusts.
		/// </summary>
		[NativeName("on_select_client_certificate")]
		public unsafe int OnSelectClientCertificate(cef_browser_t* browser, int isProxy, [Immutable]cef_string_t* host, int port, UIntPtr certificatesCount, [Immutable]cef_x509certificate_t** certificates, cef_select_client_certificate_callback_t* callback)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, int, cef_string_t*, int, UIntPtr, cef_x509certificate_t**, cef_select_client_certificate_callback_t*, int>)on_select_client_certificate)(self, browser, isProxy, host, port, certificatesCount, certificates, callback);
			}
		}

		/// <summary>
		/// void (*)(_cef_request_handler_t* self, _cef_browser_t* browser, const cef_string_t* plugin_path)*
		/// </summary>
		public void* on_plugin_crashed;

		/// <summary>
		/// Called on the browser process UI thread when a plugin has crashed.
		/// |plugin_path| is the path of the plugin that crashed.
		/// </summary>
		[NativeName("on_plugin_crashed")]
		public unsafe void OnPluginCrashed(cef_browser_t* browser, [Immutable]cef_string_t* plugin_path)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, cef_string_t*, void>)on_plugin_crashed)(self, browser, plugin_path);
			}
		}

		/// <summary>
		/// void (*)(_cef_request_handler_t* self, _cef_browser_t* browser)*
		/// </summary>
		public void* on_render_view_ready;

		/// <summary>
		/// Called on the browser process UI thread when the render view associated
		/// with |browser| is ready to receive/handle IPC messages in the render
		/// process.
		/// </summary>
		[NativeName("on_render_view_ready")]
		public unsafe void OnRenderViewReady(cef_browser_t* browser)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, void>)on_render_view_ready)(self, browser);
			}
		}

		/// <summary>
		/// void (*)(_cef_request_handler_t* self, _cef_browser_t* browser, cef_termination_status_t status)*
		/// </summary>
		public void* on_render_process_terminated;

		/// <summary>
		/// Called on the browser process UI thread when the render process terminates
		/// unexpectedly. |status| indicates how the process terminated.
		/// </summary>
		[NativeName("on_render_process_terminated")]
		public unsafe void OnRenderProcessTerminated(cef_browser_t* browser, CefTerminationStatus status)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, CefTerminationStatus, void>)on_render_process_terminated)(self, browser, status);
			}
		}

		/// <summary>
		/// void (*)(_cef_request_handler_t* self, _cef_browser_t* browser)*
		/// </summary>
		public void* on_document_available_in_main_frame;

		/// <summary>
		/// Called on the browser process UI thread when the window.document object of
		/// the main frame has been created.
		/// </summary>
		[NativeName("on_document_available_in_main_frame")]
		public unsafe void OnDocumentAvailableInMainFrame(cef_browser_t* browser)
		{
			fixed (cef_request_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_request_handler_t*, cef_browser_t*, void>)on_document_available_in_main_frame)(self, browser);
			}
		}
	}
}

