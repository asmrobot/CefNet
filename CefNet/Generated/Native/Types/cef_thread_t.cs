// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_thread_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// A simple thread abstraction that establishes a message loop on a new thread.
	/// The consumer uses cef_task_runner_t to execute code on the thread&apos;s message
	/// loop. The thread is terminated when the cef_thread_t object is destroyed or
	/// stop() is called. All pending tasks queued on the thread&apos;s message loop will
	/// run to completion before the thread is terminated. cef_thread_create() can be
	/// called on any valid CEF thread in either the browser or render process. This
	/// structure should only be used for tasks that require a dedicated thread. In
	/// most cases you can post tasks to an existing CEF thread instead of creating a
	/// new one; see cef_task.h for details.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_thread_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// _cef_task_runner_t* (*)(_cef_thread_t* self)*
		/// </summary>
		public void* get_task_runner;

		/// <summary>
		/// Returns the cef_task_runner_t that will execute code on this thread&apos;s
		/// message loop. This function is safe to call from any thread.
		/// </summary>
		[NativeName("get_task_runner")]
		public unsafe cef_task_runner_t* GetTaskRunner()
		{
			fixed (cef_thread_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_thread_t*, cef_task_runner_t*>)get_task_runner)(self);
			}
		}

		/// <summary>
		/// cef_platform_thread_id_t (*)(_cef_thread_t* self)*
		/// </summary>
		public void* get_platform_thread_id;

		/// <summary>
		/// Returns the platform thread ID. It will return the same value after stop()
		/// is called. This function is safe to call from any thread.
		/// </summary>
		[NativeName("get_platform_thread_id")]
		public unsafe uint GetPlatformThreadId()
		{
			fixed (cef_thread_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_thread_t*, uint>)get_platform_thread_id)(self);
			}
		}

		/// <summary>
		/// void (*)(_cef_thread_t* self)*
		/// </summary>
		public void* stop;

		/// <summary>
		/// Stop and join the thread. This function must be called from the same thread
		/// that called cef_thread_create(). Do not call this function if
		/// cef_thread_create() was called with a |stoppable| value of false (0).
		/// </summary>
		[NativeName("stop")]
		public unsafe void Stop()
		{
			fixed (cef_thread_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_thread_t*, void>)stop)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_thread_t* self)*
		/// </summary>
		public void* is_running;

		/// <summary>
		/// Returns true (1) if the thread is currently running. This function must be
		/// called from the same thread that called cef_thread_create().
		/// </summary>
		[NativeName("is_running")]
		public unsafe int IsRunning()
		{
			fixed (cef_thread_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_thread_t*, int>)is_running)(self);
			}
		}
	}
}

