// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_drag_data_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Structure used to represent drag data. The functions of this structure may be
	/// called on any thread.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_drag_data_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// _cef_drag_data_t* (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* clone;

		/// <summary>
		/// Returns a copy of the current object.
		/// </summary>
		[NativeName("clone")]
		public unsafe cef_drag_data_t* Clone()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_drag_data_t*>)clone)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* is_read_only;

		/// <summary>
		/// Returns true (1) if this object is read-only.
		/// </summary>
		[NativeName("is_read_only")]
		public unsafe int IsReadOnly()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, int>)is_read_only)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* is_link;

		/// <summary>
		/// Returns true (1) if the drag data is a link.
		/// </summary>
		[NativeName("is_link")]
		public unsafe int IsLink()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, int>)is_link)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* is_fragment;

		/// <summary>
		/// Returns true (1) if the drag data is a text or html fragment.
		/// </summary>
		[NativeName("is_fragment")]
		public unsafe int IsFragment()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, int>)is_fragment)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* is_file;

		/// <summary>
		/// Returns true (1) if the drag data is a file.
		/// </summary>
		[NativeName("is_file")]
		public unsafe int IsFile()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, int>)is_file)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_link_url;

		/// <summary>
		/// Return the link URL that is being dragged.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_link_url")]
		public unsafe cef_string_userfree_t GetLinkUrl()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_userfree_t>)get_link_url)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_link_title;

		/// <summary>
		/// Return the title associated with the link being dragged.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_link_title")]
		public unsafe cef_string_userfree_t GetLinkTitle()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_userfree_t>)get_link_title)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_link_metadata;

		/// <summary>
		/// Return the metadata, if any, associated with the link being dragged.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_link_metadata")]
		public unsafe cef_string_userfree_t GetLinkMetadata()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_userfree_t>)get_link_metadata)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_fragment_text;

		/// <summary>
		/// Return the plain text fragment that is being dragged.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_fragment_text")]
		public unsafe cef_string_userfree_t GetFragmentText()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_userfree_t>)get_fragment_text)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_fragment_html;

		/// <summary>
		/// Return the text/html fragment that is being dragged.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_fragment_html")]
		public unsafe cef_string_userfree_t GetFragmentHtml()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_userfree_t>)get_fragment_html)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_fragment_base_url;

		/// <summary>
		/// Return the base URL that the fragment came from. This value is used for
		/// resolving relative URLs and may be NULL.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_fragment_base_url")]
		public unsafe cef_string_userfree_t GetFragmentBaseUrl()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_userfree_t>)get_fragment_base_url)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_file_name;

		/// <summary>
		/// Return the name of the file being dragged out of the browser window.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_file_name")]
		public unsafe cef_string_userfree_t GetFileName()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_userfree_t>)get_file_name)(self);
			}
		}

		/// <summary>
		/// size_t (*)(_cef_drag_data_t* self, _cef_stream_writer_t* writer)*
		/// </summary>
		public void* get_file_contents;

		/// <summary>
		/// Write the contents of the file being dragged out of the web view into
		/// |writer|. Returns the number of bytes sent to |writer|. If |writer| is NULL
		/// this function will return the size of the file contents in bytes. Call
		/// get_file_name() to get a suggested name for the file.
		/// </summary>
		[NativeName("get_file_contents")]
		public unsafe UIntPtr GetFileContents(cef_stream_writer_t* writer)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_stream_writer_t*, UIntPtr>)get_file_contents)(self, writer);
			}
		}

		/// <summary>
		/// int (*)(_cef_drag_data_t* self, cef_string_list_t names)*
		/// </summary>
		public void* get_file_names;

		/// <summary>
		/// Retrieve the list of file names that are being dragged into the browser
		/// window.
		/// </summary>
		[NativeName("get_file_names")]
		public unsafe int GetFileNames(cef_string_list_t names)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_list_t, int>)get_file_names)(self, names);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self, const cef_string_t* url)*
		/// </summary>
		public void* set_link_url;

		/// <summary>
		/// Set the link URL that is being dragged.
		/// </summary>
		[NativeName("set_link_url")]
		public unsafe void SetLinkUrl([Immutable]cef_string_t* url)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_t*, void>)set_link_url)(self, url);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self, const cef_string_t* title)*
		/// </summary>
		public void* set_link_title;

		/// <summary>
		/// Set the title associated with the link being dragged.
		/// </summary>
		[NativeName("set_link_title")]
		public unsafe void SetLinkTitle([Immutable]cef_string_t* title)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_t*, void>)set_link_title)(self, title);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self, const cef_string_t* data)*
		/// </summary>
		public void* set_link_metadata;

		/// <summary>
		/// Set the metadata associated with the link being dragged.
		/// </summary>
		[NativeName("set_link_metadata")]
		public unsafe void SetLinkMetadata([Immutable]cef_string_t* data)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_t*, void>)set_link_metadata)(self, data);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self, const cef_string_t* text)*
		/// </summary>
		public void* set_fragment_text;

		/// <summary>
		/// Set the plain text fragment that is being dragged.
		/// </summary>
		[NativeName("set_fragment_text")]
		public unsafe void SetFragmentText([Immutable]cef_string_t* text)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_t*, void>)set_fragment_text)(self, text);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self, const cef_string_t* html)*
		/// </summary>
		public void* set_fragment_html;

		/// <summary>
		/// Set the text/html fragment that is being dragged.
		/// </summary>
		[NativeName("set_fragment_html")]
		public unsafe void SetFragmentHtml([Immutable]cef_string_t* html)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_t*, void>)set_fragment_html)(self, html);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self, const cef_string_t* base_url)*
		/// </summary>
		public void* set_fragment_base_url;

		/// <summary>
		/// Set the base URL that the fragment came from.
		/// </summary>
		[NativeName("set_fragment_base_url")]
		public unsafe void SetFragmentBaseUrl([Immutable]cef_string_t* base_url)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_t*, void>)set_fragment_base_url)(self, base_url);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* reset_file_contents;

		/// <summary>
		/// Reset the file contents. You should do this before calling
		/// cef_browser_host_t::DragTargetDragEnter as the web view does not allow us
		/// to drag in this kind of data.
		/// </summary>
		[NativeName("reset_file_contents")]
		public unsafe void ResetFileContents()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, void>)reset_file_contents)(self);
			}
		}

		/// <summary>
		/// void (*)(_cef_drag_data_t* self, const cef_string_t* path, const cef_string_t* display_name)*
		/// </summary>
		public void* add_file;

		/// <summary>
		/// Add a file that is being dragged into the webview.
		/// </summary>
		[NativeName("add_file")]
		public unsafe void AddFile([Immutable]cef_string_t* path, [Immutable]cef_string_t* display_name)
		{
			fixed (cef_drag_data_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_string_t*, cef_string_t*, void>)add_file)(self, path, display_name);
			}
		}

		/// <summary>
		/// _cef_image_t* (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_image;

		/// <summary>
		/// Get the image representation of drag data. May return NULL if no image
		/// representation is available.
		/// </summary>
		[NativeName("get_image")]
		public unsafe cef_image_t* GetImage()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_image_t*>)get_image)(self);
			}
		}

		/// <summary>
		/// cef_point_t (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* get_image_hotspot;

		/// <summary>
		/// Get the image hotspot (drag start location relative to image dimensions).
		/// </summary>
		[NativeName("get_image_hotspot")]
		public unsafe cef_point_t GetImageHotspot()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, cef_point_t>)get_image_hotspot)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_drag_data_t* self)*
		/// </summary>
		public void* has_image;

		/// <summary>
		/// Returns true (1) if an image representation of drag data is available.
		/// </summary>
		[NativeName("has_image")]
		public unsafe int HasImage()
		{
			fixed (cef_drag_data_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_drag_data_t*, int>)has_image)(self);
			}
		}
	}
}

