// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_server_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Structure representing a server that supports HTTP and WebSocket requests.
	/// Server capacity is limited and is intended to handle only a small number of
	/// simultaneous connections (e.g. for communicating between applications on
	/// localhost). The functions of this structure are safe to call from any thread
	/// in the brower process unless otherwise indicated.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_server_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// _cef_task_runner_t* (*)(_cef_server_t* self)*
		/// </summary>
		public void* get_task_runner;

		/// <summary>
		/// Returns the task runner for the dedicated server thread.
		/// </summary>
		[NativeName("get_task_runner")]
		public unsafe cef_task_runner_t* GetTaskRunner()
		{
			fixed (cef_server_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_server_t*, cef_task_runner_t*>)get_task_runner)(self);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self)*
		/// </summary>
		public void* shutdown;

		/// <summary>
		/// Stop the server and shut down the dedicated server thread. See
		/// cef_server_handler_t::OnServerCreated documentation for a description of
		/// server lifespan.
		/// </summary>
		[NativeName("shutdown")]
		public unsafe void Shutdown()
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, void>)shutdown)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_server_t* self)*
		/// </summary>
		public void* is_running;

		/// <summary>
		/// Returns true (1) if the server is currently running and accepting incoming
		/// connections. See cef_server_handler_t::OnServerCreated documentation for a
		/// description of server lifespan. This function must be called on the
		/// dedicated server thread.
		/// </summary>
		[NativeName("is_running")]
		public unsafe int IsRunning()
		{
			fixed (cef_server_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_server_t*, int>)is_running)(self);
			}
		}

		/// <summary>
		/// cef_string_userfree_t (*)(_cef_server_t* self)*
		/// </summary>
		public void* get_address;

		/// <summary>
		/// Returns the server address including the port number.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		[NativeName("get_address")]
		public unsafe cef_string_userfree_t GetAddress()
		{
			fixed (cef_server_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_server_t*, cef_string_userfree_t>)get_address)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_server_t* self)*
		/// </summary>
		public void* has_connection;

		/// <summary>
		/// Returns true (1) if the server currently has a connection. This function
		/// must be called on the dedicated server thread.
		/// </summary>
		[NativeName("has_connection")]
		public unsafe int HasConnection()
		{
			fixed (cef_server_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_server_t*, int>)has_connection)(self);
			}
		}

		/// <summary>
		/// int (*)(_cef_server_t* self, int connection_id)*
		/// </summary>
		public void* is_valid_connection;

		/// <summary>
		/// Returns true (1) if |connection_id| represents a valid connection. This
		/// function must be called on the dedicated server thread.
		/// </summary>
		[NativeName("is_valid_connection")]
		public unsafe int IsValidConnection(int connection_id)
		{
			fixed (cef_server_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_server_t*, int, int>)is_valid_connection)(self, connection_id);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self, int connection_id, const cef_string_t* content_type, const void* data, size_t data_size)*
		/// </summary>
		public void* send_http200response;

		/// <summary>
		/// Send an HTTP 200 &quot;OK&quot; response to the connection identified by
		/// |connection_id|. |content_type| is the response content type (e.g.
		/// &quot;text/html&quot;), |data| is the response content, and |data_size| is the size
		/// of |data| in bytes. The contents of |data| will be copied. The connection
		/// will be closed automatically after the response is sent.
		/// </summary>
		[NativeName("send_http200response")]
		public unsafe void SendHttp200response(int connection_id, [Immutable]cef_string_t* content_type, [Immutable]void* data, UIntPtr data_size)
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, int, cef_string_t*, void*, UIntPtr, void>)send_http200response)(self, connection_id, content_type, data, data_size);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self, int connection_id)*
		/// </summary>
		public void* send_http404response;

		/// <summary>
		/// Send an HTTP 404 &quot;Not Found&quot; response to the connection identified by
		/// |connection_id|. The connection will be closed automatically after the
		/// response is sent.
		/// </summary>
		[NativeName("send_http404response")]
		public unsafe void SendHttp404response(int connection_id)
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, int, void>)send_http404response)(self, connection_id);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self, int connection_id, const cef_string_t* error_message)*
		/// </summary>
		public void* send_http500response;

		/// <summary>
		/// Send an HTTP 500 &quot;Internal Server Error&quot; response to the connection
		/// identified by |connection_id|. |error_message| is the associated error
		/// message. The connection will be closed automatically after the response is
		/// sent.
		/// </summary>
		[NativeName("send_http500response")]
		public unsafe void SendHttp500response(int connection_id, [Immutable]cef_string_t* error_message)
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, int, cef_string_t*, void>)send_http500response)(self, connection_id, error_message);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self, int connection_id, int response_code, const cef_string_t* content_type, int64 content_length, cef_string_multimap_t extra_headers)*
		/// </summary>
		public void* send_http_response;

		/// <summary>
		/// Send a custom HTTP response to the connection identified by
		/// |connection_id|. |response_code| is the HTTP response code sent in the
		/// status line (e.g. 200), |content_type| is the response content type sent as
		/// the &quot;Content-Type&quot; header (e.g. &quot;text/html&quot;), |content_length| is the
		/// expected content length, and |extra_headers| is the map of extra response
		/// headers. If |content_length| is &gt;= 0 then the &quot;Content-Length&quot; header will
		/// be sent. If |content_length| is 0 then no content is expected and the
		/// connection will be closed automatically after the response is sent. If
		/// |content_length| is 
		/// &lt;
		/// 0 then no &quot;Content-Length&quot; header will be sent and
		/// the client will continue reading until the connection is closed. Use the
		/// SendRawData function to send the content, if applicable, and call
		/// CloseConnection after all content has been sent.
		/// </summary>
		[NativeName("send_http_response")]
		public unsafe void SendHttpResponse(int connection_id, int response_code, [Immutable]cef_string_t* content_type, long content_length, cef_string_multimap_t extra_headers)
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, int, int, cef_string_t*, long, cef_string_multimap_t, void>)send_http_response)(self, connection_id, response_code, content_type, content_length, extra_headers);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self, int connection_id, const void* data, size_t data_size)*
		/// </summary>
		public void* send_raw_data;

		/// <summary>
		/// Send raw data directly to the connection identified by |connection_id|.
		/// |data| is the raw data and |data_size| is the size of |data| in bytes. The
		/// contents of |data| will be copied. No validation of |data| is performed
		/// internally so the client should be careful to send the amount indicated by
		/// the &quot;Content-Length&quot; header, if specified. See SendHttpResponse
		/// documentation for intended usage.
		/// </summary>
		[NativeName("send_raw_data")]
		public unsafe void SendRawData(int connection_id, [Immutable]void* data, UIntPtr data_size)
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, int, void*, UIntPtr, void>)send_raw_data)(self, connection_id, data, data_size);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self, int connection_id)*
		/// </summary>
		public void* close_connection;

		/// <summary>
		/// Close the connection identified by |connection_id|. See SendHttpResponse
		/// documentation for intended usage.
		/// </summary>
		[NativeName("close_connection")]
		public unsafe void CloseConnection(int connection_id)
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, int, void>)close_connection)(self, connection_id);
			}
		}

		/// <summary>
		/// void (*)(_cef_server_t* self, int connection_id, const void* data, size_t data_size)*
		/// </summary>
		public void* send_web_socket_message;

		/// <summary>
		/// Send a WebSocket message to the connection identified by |connection_id|.
		/// |data| is the response content and |data_size| is the size of |data| in
		/// bytes. The contents of |data| will be copied. See
		/// cef_server_handler_t::OnWebSocketRequest documentation for intended usage.
		/// </summary>
		[NativeName("send_web_socket_message")]
		public unsafe void SendWebSocketMessage(int connection_id, [Immutable]void* data, UIntPtr data_size)
		{
			fixed (cef_server_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_server_t*, int, void*, UIntPtr, void>)send_web_socket_message)(self, connection_id, data, data_size);
			}
		}
	}
}

