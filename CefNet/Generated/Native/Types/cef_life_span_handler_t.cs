// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: include/capi/cef_life_span_handler_capi.h
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	/// <summary>
	/// Implement this structure to handle events related to browser life span. The
	/// functions of this structure will be called on the UI thread unless otherwise
	/// indicated.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct cef_life_span_handler_t
	{
		/// <summary>
		/// Base structure.
		/// </summary>
		public cef_base_ref_counted_t @base;

		/// <summary>
		/// int (*)(_cef_life_span_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, const cef_string_t* target_url, const cef_string_t* target_frame_name, cef_window_open_disposition_t target_disposition, int user_gesture, const const _cef_popup_features_t* popupFeatures, _cef_window_info_t* windowInfo, _cef_client_t** client, _cef_browser_settings_t* settings, _cef_dictionary_value_t** extra_info, int* no_javascript_access)*
		/// </summary>
		public void* on_before_popup;

		/// <summary>
		/// Called on the UI thread before a new popup browser is created. The
		/// |browser| and |frame| values represent the source of the popup request. The
		/// |target_url| and |target_frame_name| values indicate where the popup
		/// browser should navigate and may be NULL if not specified with the request.
		/// The |target_disposition| value indicates where the user intended to open
		/// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
		/// be true (1) if the popup was opened via explicit user gesture (e.g.
		/// clicking a link) or false (0) if the popup opened automatically (e.g. via
		/// the DomContentLoaded event). The |popupFeatures| structure contains
		/// additional information about the requested popup window. To allow creation
		/// of the popup browser optionally modify |windowInfo|, |client|, |settings|
		/// and |no_javascript_access| and return false (0). To cancel creation of the
		/// popup browser return true (1). The |client| and |settings| values will
		/// default to the source browser&apos;s values. If the |no_javascript_access| value
		/// is set to false (0) the new browser will not be scriptable and may not be
		/// hosted in the same renderer process as the source browser. Any
		/// modifications to |windowInfo| will be ignored if the parent browser is
		/// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
		/// the parent browser is destroyed before the popup browser creation completes
		/// (indicated by a call to OnAfterCreated for the popup browser). The
		/// |extra_info| parameter provides an opportunity to specify extra information
		/// specific to the created popup browser that will be passed to
		/// cef_render_process_handler_t::on_browser_created() in the render process.
		/// </summary>
		[NativeName("on_before_popup")]
		public unsafe int OnBeforePopup(cef_browser_t* browser, cef_frame_t* frame, [Immutable]cef_string_t* target_url, [Immutable]cef_string_t* target_frame_name, CefWindowOpenDisposition target_disposition, int user_gesture, [Immutable]cef_popup_features_t* popupFeatures, cef_window_info_t* windowInfo, cef_client_t** client, cef_browser_settings_t* settings, cef_dictionary_value_t** extra_info, int* no_javascript_access)
		{
			fixed (cef_life_span_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_life_span_handler_t*, cef_browser_t*, cef_frame_t*, cef_string_t*, cef_string_t*, CefWindowOpenDisposition, int, cef_popup_features_t*, cef_window_info_t*, cef_client_t**, cef_browser_settings_t*, cef_dictionary_value_t**, int*, int>)on_before_popup)(self, browser, frame, target_url, target_frame_name, target_disposition, user_gesture, popupFeatures, windowInfo, client, settings, extra_info, no_javascript_access);
			}
		}

		/// <summary>
		/// void (*)(_cef_life_span_handler_t* self, _cef_browser_t* browser)*
		/// </summary>
		public void* on_after_created;

		/// <summary>
		/// Called after a new browser is created. It is now safe to begin performing
		/// actions with |browser|. cef_frame_handler_t callbacks related to initial
		/// main frame creation will arrive before this callback. See
		/// cef_frame_handler_t documentation for additional usage information.
		/// </summary>
		[NativeName("on_after_created")]
		public unsafe void OnAfterCreated(cef_browser_t* browser)
		{
			fixed (cef_life_span_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_life_span_handler_t*, cef_browser_t*, void>)on_after_created)(self, browser);
			}
		}

		/// <summary>
		/// int (*)(_cef_life_span_handler_t* self, _cef_browser_t* browser)*
		/// </summary>
		public void* do_close;

		/// <summary>
		/// Called when a browser has recieved a request to close. This may result
		/// directly from a call to cef_browser_host_t::*close_browser() or indirectly
		/// if the browser is parented to a top-level window created by CEF and the
		/// user attempts to close that window (by clicking the &apos;X&apos;, for example). The
		/// do_close() function will be called after the JavaScript &apos;onunload&apos; event
		/// has been fired.
		/// An application should handle top-level owner window close notifications by
		/// calling cef_browser_host_t::try_close_browser() or
		/// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
		/// to close immediately (see the examples below). This gives CEF an
		/// opportunity to process the &apos;onbeforeunload&apos; event and optionally cancel the
		/// close before do_close() is called.
		/// When windowed rendering is enabled CEF will internally create a window or
		/// view to host the browser. In that case returning false (0) from do_close()
		/// will send the standard close notification to the browser&apos;s top-level owner
		/// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
		/// Linux or cef_window_delegate_t::can_close() callback from Views). If the
		/// browser&apos;s host window/view has already been destroyed (via view hierarchy
		/// tear-down, for example) then do_close() will not be called for that browser
		/// since is no longer possible to cancel the close.
		/// When windowed rendering is disabled returning false (0) from do_close()
		/// will cause the browser object to be destroyed immediately.
		/// If the browser&apos;s top-level owner window requires a non-standard close
		/// notification then send that notification from do_close() and return true
		/// (1).
		/// The cef_life_span_handler_t::on_before_close() function will be called
		/// after do_close() (if do_close() is called) and immediately before the
		/// browser object is destroyed. The application should only exit after
		/// on_before_close() has been called for all existing browsers.
		/// The below examples describe what should happen during window close when the
		/// browser is parented to an application-provided top-level window.
		/// Example 1: Using cef_browser_host_t::try_close_browser(). This is
		/// recommended for clients using standard close handling and windows created
		/// on the browser process UI thread. 1.  User clicks the window close button
		/// which sends a close notification to
		/// the application&apos;s top-level window.
		/// 2.  Application&apos;s top-level window receives the close notification and
		/// calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
		/// TryCloseBrowser() returns false so the client cancels the window close.
		/// 3.  JavaScript &apos;onbeforeunload&apos; handler executes and shows the close
		/// confirmation dialog (which can be overridden via
		/// CefJSDialogHandler::OnBeforeUnloadDialog()).
		/// 4.  User approves the close. 5.  JavaScript &apos;onunload&apos; handler executes. 6.
		/// CEF sends a close notification to the application&apos;s top-level window
		/// (because DoClose() returned false by default).
		/// 7.  Application&apos;s top-level window receives the close notification and
		/// calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
		/// allows the window close.
		/// 8.  Application&apos;s top-level window is destroyed. 9.  Application&apos;s
		/// on_before_close() handler is called and the browser object
		/// is destroyed.
		/// 10. Application exits by calling cef_quit_message_loop() if no other
		/// browsers
		/// exist.
		/// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
		/// implementing the do_close() callback. This is recommended for clients using
		/// non-standard close handling or windows that were not created on the browser
		/// process UI thread. 1.  User clicks the window close button which sends a
		/// close notification to
		/// the application&apos;s top-level window.
		/// 2.  Application&apos;s top-level window receives the close notification and:
		/// A. Calls CefBrowserHost::CloseBrowser(false).
		/// B. Cancels the window close.
		/// 3.  JavaScript &apos;onbeforeunload&apos; handler executes and shows the close
		/// confirmation dialog (which can be overridden via
		/// CefJSDialogHandler::OnBeforeUnloadDialog()).
		/// 4.  User approves the close. 5.  JavaScript &apos;onunload&apos; handler executes. 6.
		/// Application&apos;s do_close() handler is called. Application will:
		/// A. Set a flag to indicate that the next close attempt will be allowed.
		/// B. Return false.
		/// 7.  CEF sends an close notification to the application&apos;s top-level window.
		/// 8.  Application&apos;s top-level window receives the close notification and
		/// allows the window to close based on the flag from #6B.
		/// 9.  Application&apos;s top-level window is destroyed. 10. Application&apos;s
		/// on_before_close() handler is called and the browser object
		/// is destroyed.
		/// 11. Application exits by calling cef_quit_message_loop() if no other
		/// browsers
		/// exist.
		/// </summary>
		[NativeName("do_close")]
		public unsafe int DoClose(cef_browser_t* browser)
		{
			fixed (cef_life_span_handler_t* self = &this)
			{
				return ((delegate* unmanaged[Stdcall]<cef_life_span_handler_t*, cef_browser_t*, int>)do_close)(self, browser);
			}
		}

		/// <summary>
		/// void (*)(_cef_life_span_handler_t* self, _cef_browser_t* browser)*
		/// </summary>
		public void* on_before_close;

		/// <summary>
		/// Called just before a browser is destroyed. Release all references to the
		/// browser object and do not attempt to execute any functions on the browser
		/// object (other than IsValid, GetIdentifier or IsSame) after this callback
		/// returns. cef_frame_handler_t callbacks related to final main frame
		/// destruction will arrive after this callback and cef_browser_t::IsValid will
		/// return false (0) at that time. Any in-progress network requests associated
		/// with |browser| will be aborted when the browser is destroyed, and
		/// cef_resource_request_handler_t callbacks related to those requests may
		/// still arrive on the IO thread after this callback. See cef_frame_handler_t
		/// and do_close() documentation for additional usage information.
		/// </summary>
		[NativeName("on_before_close")]
		public unsafe void OnBeforeClose(cef_browser_t* browser)
		{
			fixed (cef_life_span_handler_t* self = &this)
			{
				((delegate* unmanaged[Stdcall]<cef_life_span_handler_t*, cef_browser_t*, void>)on_before_close)(self, browser);
			}
		}
	}
}

