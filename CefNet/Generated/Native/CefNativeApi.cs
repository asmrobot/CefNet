// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: 
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;

namespace CefNet.CApi
{
	public static partial class CefNativeApi
	{
		public static readonly string ApiHash = "6f6a9c0f3b420cd3120cf4f5924cbc91f5095abd";

		/// <summary>
		/// Add an entry to the cross-origin access whitelist.
		/// The same-origin policy restricts how scripts hosted from different origins
		/// (scheme + domain + port) can communicate. By default, scripts can only access
		/// resources with the same origin. Scripts hosted on the HTTP and HTTPS schemes
		/// (but no other schemes) can use the &quot;Access-Control-Allow-Origin&quot; header to
		/// allow cross-origin requests. For example, https://source.example.com can make
		/// XMLHttpRequest requests on http://target.example.com if the
		/// http://target.example.com request returns an &quot;Access-Control-Allow-Origin:
		/// https://source.example.com&quot; response header.
		/// Scripts in separate frames or iframes and hosted from the same protocol and
		/// domain suffix can execute cross-origin JavaScript if both pages set the
		/// document.domain value to the same domain suffix. For example,
		/// scheme://foo.example.com and scheme://bar.example.com can communicate using
		/// JavaScript if both domains set document.domain=&quot;example.com&quot;.
		/// This function is used to allow access to origins that would otherwise violate
		/// the same-origin policy. Scripts hosted underneath the fully qualified
		/// |source_origin| URL (like http://www.example.com) will be allowed access to
		/// all resources hosted on the specified |target_protocol| and |target_domain|.
		/// If |target_domain| is non-NULL and |allow_target_subdomains| if false (0)
		/// only exact domain matches will be allowed. If |target_domain| contains a top-
		/// level domain component (like &quot;example.com&quot;) and |allow_target_subdomains| is
		/// true (1) sub-domain matches will be allowed. If |target_domain| is NULL and
		/// |allow_target_subdomains| if true (1) all domains and IP addresses will be
		/// allowed.
		/// This function cannot be used to bypass the restrictions on local or display
		/// isolated schemes. See the comments on CefRegisterCustomScheme for more
		/// information.
		/// This function may be called on any thread. Returns false (0) if
		/// |source_origin| is invalid or the whitelist cannot be accessed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_origin_whitelist_capi.h as
		/// int cef_add_cross_origin_whitelist_entry(const cef_string_t* source_origin, const cef_string_t* target_protocol, const cef_string_t* target_domain, int allow_target_subdomains)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_add_cross_origin_whitelist_entry(cef_string_t* source_origin, cef_string_t* target_protocol, cef_string_t* target_domain, int allow_target_subdomains);

		/// <summary>
		/// Returns CEF API hashes for the libcef library. The returned string is owned
		/// by the library and should not be freed. The |entry| parameter describes which
		/// hash value will be returned:
		/// 0 - CEF_API_HASH_PLATFORM
		/// 1 - CEF_API_HASH_UNIVERSAL
		/// 2 - CEF_COMMIT_HASH (from cef_version.h)
		/// </summary>
		/// <remarks>
		/// Defined in include/cef_api_hash.h as
		/// const char* cef_api_hash(int entry)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern IntPtr cef_api_hash(int entry);

		/// <summary>
		/// Decodes the base64 encoded string |data|. The returned value will be NULL if
		/// the decoding fails.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// _cef_binary_value_t* cef_base64decode(const cef_string_t* data)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_binary_value_t* cef_base64decode(cef_string_t* data);

		/// <summary>
		/// Encodes |data| as a base64 string.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// cef_string_userfree_t cef_base64encode(const void* data, size_t data_size)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_t cef_base64encode(void* data, UIntPtr data_size);

		/// <summary>
		/// Start tracing events on all processes. Tracing is initialized asynchronously
		/// and |callback| will be executed on the UI thread after initialization is
		/// complete.
		/// If CefBeginTracing was called previously, or if a CefEndTracingAsync call is
		/// pending, CefBeginTracing will fail and return false (0).
		/// |categories| is a comma-delimited list of category wildcards. A category can
		/// have an optional &apos;-&apos; prefix to make it an excluded category. Having both
		/// included and excluded categories in the same list is not supported.
		/// Example: &quot;test_MyTest*&quot; Example: &quot;test_MyTest*,test_OtherStuff&quot; Example:
		/// &quot;-excluded_category1,-excluded_category2&quot;
		/// This function must be called on the browser process UI thread.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_trace_capi.h as
		/// int cef_begin_tracing(const cef_string_t* categories, _cef_completion_callback_t* callback)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_begin_tracing(cef_string_t* categories, cef_completion_callback_t* callback);

		/// <summary>
		/// Creates a new object that is not owned by any other object. The specified
		/// |data| will be copied.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_values_capi.h as
		/// cef_binary_value_t* cef_binary_value_create(const void* data, size_t data_size)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_binary_value_t* cef_binary_value_create(void* data, UIntPtr data_size);

		/// <summary>
		/// Create a new browser using the window parameters specified by |windowInfo|.
		/// All values will be copied internally and the actual window (if any) will be
		/// created on the UI thread. If |request_context| is NULL the global request
		/// context will be used. This function can be called on any browser process
		/// thread and will not block. The optional |extra_info| parameter provides an
		/// opportunity to specify extra information specific to the created browser that
		/// will be passed to cef_render_process_handler_t::on_browser_created() in the
		/// render process.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_browser_capi.h as
		/// int cef_browser_host_create_browser(const cef_window_info_t* windowInfo, _cef_client_t* client, const cef_string_t* url, const const _cef_browser_settings_t* settings, _cef_dictionary_value_t* extra_info, _cef_request_context_t* request_context)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_browser_host_create_browser(cef_window_info_t* windowInfo, cef_client_t* client, cef_string_t* url, cef_browser_settings_t* settings, cef_dictionary_value_t* extra_info, cef_request_context_t* request_context);

		/// <summary>
		/// Create a new browser using the window parameters specified by |windowInfo|.
		/// If |request_context| is NULL the global request context will be used. This
		/// function can only be called on the browser process UI thread. The optional
		/// |extra_info| parameter provides an opportunity to specify extra information
		/// specific to the created browser that will be passed to
		/// cef_render_process_handler_t::on_browser_created() in the render process.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_browser_capi.h as
		/// cef_browser_t* cef_browser_host_create_browser_sync(const cef_window_info_t* windowInfo, _cef_client_t* client, const cef_string_t* url, const const _cef_browser_settings_t* settings, _cef_dictionary_value_t* extra_info, _cef_request_context_t* request_context)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_browser_t* cef_browser_host_create_browser_sync(cef_window_info_t* windowInfo, cef_client_t* client, cef_string_t* url, cef_browser_settings_t* settings, cef_dictionary_value_t* extra_info, cef_request_context_t* request_context);

		/// <summary>
		/// Remove all entries from the cross-origin access whitelist. Returns false (0)
		/// if the whitelist cannot be accessed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_origin_whitelist_capi.h as
		/// int cef_clear_cross_origin_whitelist()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_clear_cross_origin_whitelist();

		/// <summary>
		/// Clear all scheme handler factories registered with the global request
		/// context. Returns false (0) on error. This function may be called on any
		/// thread in the browser process. Using this function is equivalent to calling c
		/// ef_request_context_t::cef_request_context_get_global_context()-&gt;clear_scheme_
		/// handler_factories().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_scheme_capi.h as
		/// int cef_clear_scheme_handler_factories()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_clear_scheme_handler_factories();

		/// <summary>
		/// Create a new cef_command_line_t instance.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_command_line_capi.h as
		/// cef_command_line_t* cef_command_line_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_command_line_t* cef_command_line_create();

		/// <summary>
		/// Returns the singleton global cef_command_line_t object. The returned object
		/// will be read-only.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_command_line_capi.h as
		/// cef_command_line_t* cef_command_line_get_global()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_command_line_t* cef_command_line_get_global();

		/// <summary>
		/// Returns the global cookie manager. By default data will be stored at
		/// CefSettings.cache_path if specified or in memory otherwise. If |callback| is
		/// non-NULL it will be executed asnychronously on the UI thread after the
		/// manager&apos;s storage has been initialized. Using this function is equivalent to
		/// calling cef_request_context_t::cef_request_context_get_global_context()-&gt;GetD
		/// efaultCookieManager().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_cookie_capi.h as
		/// cef_cookie_manager_t* cef_cookie_manager_get_global_manager(_cef_completion_callback_t* callback)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_cookie_manager_t* cef_cookie_manager_get_global_manager(cef_completion_callback_t* callback);

		/// <summary>
		/// Crash reporting is configured using an INI-style config file named
		/// &quot;crash_reporter.cfg&quot;. On Windows and Linux this file must be placed next to
		/// the main application executable. On macOS this file must be placed in the
		/// top-level app bundle Resources directory (e.g.
		/// &quot;
		/// &lt;appname
		/// &gt;.app/Contents/Resources&quot;). File contents are as follows:
		/// # Comments start with a hash character and must be on their own line.
		/// [Config]
		/// ProductName=
		/// &lt;Value
		/// of the &quot;prod&quot; crash key; defaults to &quot;cef&quot;&gt;
		/// ProductVersion=
		/// &lt;Value
		/// of the &quot;ver&quot; crash key; defaults to the CEF version&gt;
		/// AppName=
		/// &lt;Windows
		/// only; App-specific folder name component for storing crash
		/// information; default to &quot;CEF&quot;&gt;
		/// ExternalHandler=
		/// &lt;Windows
		/// only; Name of the external handler exe to use
		/// instead of re-launching the main exe; default to empty&gt;
		/// BrowserCrashForwardingEnabled=
		/// &lt;macOS
		/// only; True if browser process crashes
		/// should be forwarded to the system crash
		/// reporter; default to false&gt;
		/// ServerURL=
		/// &lt;crash
		/// server URL; default to empty&gt;
		/// RateLimitEnabled=
		/// &lt;True
		/// if uploads should be rate limited; default to true&gt;
		/// MaxUploadsPerDay=
		/// &lt;Max
		/// uploads per 24 hours, used if rate limit is enabled;
		/// default to 5&gt;
		/// MaxDatabaseSizeInMb=
		/// &lt;Total
		/// crash report disk usage greater than this value
		/// will cause older reports to be deleted; default to 20&gt;
		/// MaxDatabaseAgeInDays=
		/// &lt;Crash
		/// reports older than this value will be deleted;
		/// default to 5&gt;
		/// [CrashKeys]
		/// my_key1=&lt;small&gt;|medium|large&gt;
		/// my_key2=&lt;small&gt;|medium|large&gt;
		/// Config section:
		/// If &quot;ProductName&quot; and/or &quot;ProductVersion&quot; are set then the specified values
		/// will be included in the crash dump metadata. On macOS if these values are set
		/// to NULL then they will be retrieved from the Info.plist file using the
		/// &quot;CFBundleName&quot; and &quot;CFBundleShortVersionString&quot; keys respectively.
		/// If &quot;AppName&quot; is set on Windows then crash report information (metrics,
		/// database and dumps) will be stored locally on disk under the
		/// &quot;C:@Users \
		/// [CurrentUser]@AppData @Local \
		/// [AppName]@User Data&quot; folder. On other
		/// platforms the CefSettings.user_data_path value will be used.
		/// If &quot;ExternalHandler&quot; is set on Windows then the specified exe will be
		/// launched as the crashpad-handler instead of re-launching the main process
		/// exe. The value can be an absolute path or a path relative to the main exe
		/// directory. On Linux the CefSettings.browser_subprocess_path value will be
		/// used. On macOS the existing subprocess app bundle will be used.
		/// If &quot;BrowserCrashForwardingEnabled&quot; is set to true (1) on macOS then browser
		/// process crashes will be forwarded to the system crash reporter. This results
		/// in the crash UI dialog being displayed to the user and crash reports being
		/// logged under &quot;~/Library/Logs/DiagnosticReports&quot;. Forwarding of crash reports
		/// from non-browser processes and Debug builds is always disabled.
		/// If &quot;ServerURL&quot; is set then crashes will be uploaded as a multi-part POST
		/// request to the specified URL. Otherwise, reports will only be stored locally
		/// on disk.
		/// If &quot;RateLimitEnabled&quot; is set to true (1) then crash report uploads will be
		/// rate limited as follows:
		/// 1. If &quot;MaxUploadsPerDay&quot; is set to a positive value then at most the
		/// specified number of crashes will be uploaded in each 24 hour period.
		/// 2. If crash upload fails due to a network or server error then an
		/// incremental backoff delay up to a maximum of 24 hours will be applied for
		/// retries.
		/// 3. If a backoff delay is applied and &quot;MaxUploadsPerDay&quot; is &gt; 1 then the
		/// &quot;MaxUploadsPerDay&quot; value will be reduced to 1 until the client is
		/// restarted. This helps to avoid an upload flood when the network or
		/// server error is resolved.
		/// Rate limiting is not supported on Linux.
		/// If &quot;MaxDatabaseSizeInMb&quot; is set to a positive value then crash report storage
		/// on disk will be limited to that size in megabytes. For example, on Windows
		/// each dump is about 600KB so a &quot;MaxDatabaseSizeInMb&quot; value of 20 equates to
		/// about 34 crash reports stored on disk. Not supported on Linux.
		/// If &quot;MaxDatabaseAgeInDays&quot; is set to a positive value then crash reports older
		/// than the specified age in days will be deleted. Not supported on Linux.
		/// CrashKeys section:
		/// A maximum of 26 crash keys of each size can be specified for use by the
		/// application. Crash key values will be truncated based on the specified size
		/// (small = 64 bytes, medium = 256 bytes, large = 1024 bytes). The value of
		/// crash keys can be set from any thread or process using the
		/// CefSetCrashKeyValue function. These key/value pairs will be sent to the crash
		/// server along with the crash dump file.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_crash_util_capi.h as
		/// int cef_crash_reporting_enabled()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_crash_reporting_enabled();

		/// <summary>
		/// Creates a new context object that shares storage with |other| and uses an
		/// optional |handler|.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_request_context_capi.h as
		/// cef_request_context_t* cef_create_context_shared(cef_request_context_t* other, _cef_request_context_handler_t* handler)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_request_context_t* cef_create_context_shared(cef_request_context_t* other, cef_request_context_handler_t* handler);

		/// <summary>
		/// Creates a directory and all parent directories if they don&apos;t already exist.
		/// Returns true (1) on successful creation or if the directory already exists.
		/// The directory is only readable by the current user. Calling this function on
		/// the browser process UI or IO threads is not allowed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// int cef_create_directory(const cef_string_t* full_path)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_create_directory(cef_string_t* full_path);

		/// <summary>
		/// Creates a new directory. On Windows if |prefix| is provided the new directory
		/// name is in the format of &quot;prefixyyyy&quot;. Returns true (1) on success and sets
		/// |new_temp_path| to the full path of the directory that was created. The
		/// directory is only readable by the current user. Calling this function on the
		/// browser process UI or IO threads is not allowed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// int cef_create_new_temp_directory(const cef_string_t* prefix, cef_string_t* new_temp_path)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_create_new_temp_directory(cef_string_t* prefix, cef_string_t* new_temp_path);

		/// <summary>
		/// Creates a directory within another directory. Extra characters will be
		/// appended to |prefix| to ensure that the new directory does not have the same
		/// name as an existing directory. Returns true (1) on success and sets |new_dir|
		/// to the full path of the directory that was created. The directory is only
		/// readable by the current user. Calling this function on the browser process UI
		/// or IO threads is not allowed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// int cef_create_temp_directory_in_directory(const cef_string_t* base_dir, const cef_string_t* prefix, cef_string_t* new_dir)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_create_temp_directory_in_directory(cef_string_t* base_dir, cef_string_t* prefix, cef_string_t* new_dir);

		/// <summary>
		/// Creates a URL from the specified |parts|, which must contain a non-NULL spec
		/// or a non-NULL host and path (at a minimum), but not both. Returns false (0)
		/// if |parts| isn&apos;t initialized as described.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// int cef_create_url(const const _cef_urlparts_t* parts, cef_string_t* url)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_create_url(cef_urlparts_t* parts, cef_string_t* url);

		/// <summary>
		/// Returns true (1) if called on the specified thread. Equivalent to using
		/// cef_task_runner_t::GetForThread(threadId)-&gt;belongs_to_current_thread().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_task_capi.h as
		/// int cef_currently_on(cef_thread_id_t threadId)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_currently_on(CefThreadId threadId);

		/// <summary>
		/// Deletes the given path whether it&apos;s a file or a directory. If |path| is a
		/// directory all contents will be deleted.  If |recursive| is true (1) any sub-
		/// directories and their contents will also be deleted (equivalent to executing
		/// &quot;rm -rf&quot;, so use with caution). On POSIX environments if |path| is a symbolic
		/// link then only the symlink will be deleted. Returns true (1) on successful
		/// deletion or if |path| does not exist. Calling this function on the browser
		/// process UI or IO threads is not allowed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// int cef_delete_file(const cef_string_t* path, int recursive)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_delete_file(cef_string_t* path, int recursive);

		/// <summary>
		/// Creates a new object that is not owned by any other object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_values_capi.h as
		/// cef_dictionary_value_t* cef_dictionary_value_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_dictionary_value_t* cef_dictionary_value_create();

		/// <summary>
		/// Returns true (1) if the given path exists and is a directory. Calling this
		/// function on the browser process UI or IO threads is not allowed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// int cef_directory_exists(const cef_string_t* path)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_directory_exists(cef_string_t* path);

		/// <summary>
		/// Perform a single iteration of CEF message loop processing. This function is
		/// provided for cases where the CEF message loop must be integrated into an
		/// existing application message loop. Use of this function is not recommended
		/// for most users; use either the cef_run_message_loop() function or
		/// CefSettings.multi_threaded_message_loop if possible. When using this function
		/// care must be taken to balance performance against excessive CPU usage. It is
		/// recommended to enable the CefSettings.external_message_pump option when using
		/// this function so that
		/// cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can
		/// facilitate the scheduling process. This function should only be called on the
		/// main application thread and only if cef_initialize() is called with a
		/// CefSettings.multi_threaded_message_loop value of false (0). This function
		/// will not block.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// void cef_do_message_loop_work()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_do_message_loop_work();

		/// <summary>
		/// Create a new cef_drag_data_t object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_drag_data_capi.h as
		/// cef_drag_data_t* cef_drag_data_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_drag_data_t* cef_drag_data_create();

		/// <summary>
		/// Call during process startup to enable High-DPI support on Windows 7 or newer.
		/// Older versions of Windows should be left DPI-unaware because they do not
		/// support DirectWrite and GDI fonts are kerned very badly.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// void cef_enable_highdpi_support()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_enable_highdpi_support();

		/// <summary>
		/// Stop tracing events on all processes.
		/// This function will fail and return false (0) if a previous call to
		/// CefEndTracingAsync is already pending or if CefBeginTracing was not called.
		/// |tracing_file| is the path at which tracing data will be written and
		/// |callback| is the callback that will be executed once all processes have sent
		/// their trace data. If |tracing_file| is NULL a new temporary file path will be
		/// used. If |callback| is NULL no trace data will be written.
		/// This function must be called on the browser process UI thread.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_trace_capi.h as
		/// int cef_end_tracing(const cef_string_t* tracing_file, cef_end_tracing_callback_t* callback)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_end_tracing(cef_string_t* tracing_file, cef_end_tracing_callback_t* callback);

		/// <summary>
		/// This function should be called from the application entry point function to
		/// execute a secondary process. It can be used to run secondary processes from
		/// the browser client executable (default behavior) or from a separate
		/// executable specified by the CefSettings.browser_subprocess_path value. If
		/// called for the browser process (identified by no &quot;type&quot; command-line value)
		/// it will return immediately with a value of -1. If called for a recognized
		/// secondary process it will block until the process should exit and then return
		/// the process exit code. The |application| parameter may be NULL. The
		/// |windows_sandbox_info| parameter is only used on Windows and may be NULL (see
		/// cef_sandbox_win.h for details).
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// int cef_execute_process(const const _cef_main_args_t* args, cef_app_t* application, void* windows_sandbox_info)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_execute_process(cef_main_args_t* args, cef_app_t* application, void* windows_sandbox_info);

		/// <summary>
		/// This is a convenience function for formatting a URL in a concise and human-
		/// friendly way to help users make security-related decisions (or in other
		/// circumstances when people need to distinguish sites, origins, or otherwise-
		/// simplified URLs from each other). Internationalized domain names (IDN) may be
		/// presented in Unicode if the conversion is considered safe. The returned value
		/// will (a) omit the path for standard schemes, excepting file and filesystem,
		/// and (b) omit the port if it is the default for the scheme. Do not use this
		/// for URLs which will be parsed or sent to other applications.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// cef_string_userfree_t cef_format_url_for_security_display(const cef_string_t* origin_url)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_t cef_format_url_for_security_display(cef_string_t* origin_url);

		/// <summary>
		/// Returns the current platform thread ID.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_thread_internal.h as
		/// cef_platform_thread_id_t cef_get_current_platform_thread_id()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern uint cef_get_current_platform_thread_id();

		/// <summary>
		/// Get the extensions associated with the given mime type. This should be passed
		/// in lower case. There could be multiple extensions for a given mime type, like
		/// &quot;html,htm&quot; for &quot;text/html&quot;, or &quot;txt,text,html,...&quot; for &quot;text/*&quot;. Any existing
		/// elements in the provided vector will not be erased.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// void cef_get_extensions_for_mime_type(const cef_string_t* mime_type, cef_string_list_t extensions)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_get_extensions_for_mime_type(cef_string_t* mime_type, cef_string_list_t extensions);

		/// <summary>
		/// Returns the mime type for the specified file extension or an NULL string if
		/// unknown.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// cef_string_userfree_t cef_get_mime_type(const cef_string_t* extension)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_t cef_get_mime_type(cef_string_t* extension);

		/// <summary>
		/// Retrieve the path associated with the specified |key|. Returns true (1) on
		/// success. Can be called on any thread in the browser process.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_path_util_capi.h as
		/// int cef_get_path(cef_path_key_t key, cef_string_t* path)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_get_path(CefPathKey key, cef_string_t* path);

		/// <summary>
		/// Get the temporary directory provided by the system.
		/// WARNING: In general, you should use the temp directory variants below instead
		/// of this function. Those variants will ensure that the proper permissions are
		/// set so that other users on the system can&apos;t edit them while they&apos;re open
		/// (which could lead to security issues).
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// int cef_get_temp_directory(cef_string_t* temp_dir)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_get_temp_directory(cef_string_t* temp_dir);

		/// <summary>
		/// Create a new cef_image_t. It will initially be NULL. Use the Add*() functions
		/// to add representations at different scale factors.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_image_capi.h as
		/// cef_image_t* cef_image_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_image_t* cef_image_create();

		/// <summary>
		/// This function should be called on the main application thread to initialize
		/// the CEF browser process. The |application| parameter may be NULL. A return
		/// value of true (1) indicates that it succeeded and false (0) indicates that it
		/// failed. The |windows_sandbox_info| parameter is only used on Windows and may
		/// be NULL (see cef_sandbox_win.h for details).
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// int cef_initialize(const const _cef_main_args_t* args, const const _cef_settings_t* settings, cef_app_t* application, void* windows_sandbox_info)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_initialize(cef_main_args_t* args, cef_settings_t* settings, cef_app_t* application, void* windows_sandbox_info);

		/// <summary>
		/// Returns true (1) if the certificate status represents an error.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_ssl_info_capi.h as
		/// int cef_is_cert_status_error(cef_cert_status_t status)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_is_cert_status_error(CefCertStatus status);

		/// <summary>
		/// Returns true (1) if the application text direction is right-to-left.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_i18n_util_capi.h as
		/// int cef_is_rtl()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_is_rtl();

		/// <summary>
		/// Query if a plugin is unstable. Can be called on any thread in the browser
		/// process.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_web_plugin_capi.h as
		/// void cef_is_web_plugin_unstable(const cef_string_t* path, cef_web_plugin_unstable_callback_t* callback)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_is_web_plugin_unstable(cef_string_t* path, cef_web_plugin_unstable_callback_t* callback);

		/// <summary>
		/// Launches the process specified via |command_line|. Returns true (1) upon
		/// success. Must be called on the browser process TID_PROCESS_LAUNCHER thread.
		/// Unix-specific notes: - All file descriptors open in the parent process will
		/// be closed in the
		/// child process except for stdin, stdout, and stderr.
		/// - If the first argument on the command line does not contain a slash,
		/// PATH will be searched. (See man execvp.)
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_process_util_capi.h as
		/// int cef_launch_process(_cef_command_line_t* command_line)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_launch_process(cef_command_line_t* command_line);

		/// <summary>
		/// Creates a new object that is not owned by any other object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_values_capi.h as
		/// cef_list_value_t* cef_list_value_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_list_value_t* cef_list_value_create();

		/// <summary>
		/// Loads the existing &quot;Certificate Revocation Lists&quot; file that is managed by
		/// Google Chrome. This file can generally be found in Chrome&apos;s User Data
		/// directory (e.g. &quot;C:@Users \
		/// [User]@AppData @Local @Google @Chrome @User Data
		/// &quot;
		/// on
		/// Windows) and is updated periodically by Chrome&apos;s component updater service.
		/// Must be called in the browser process after the context has been initialized.
		/// See https://dev.chromium.org/Home/chromium-security/crlsets for background.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// void cef_load_crlsets_file(const cef_string_t* path)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_load_crlsets_file(cef_string_t* path);

		/// <summary>
		/// Returns the MediaRouter object associated with the global request context. If
		/// |callback| is non-NULL it will be executed asnychronously on the UI thread
		/// after the manager&apos;s storage has been initialized. Equivalent to calling cef_r
		/// equest_context_t::cef_request_context_get_global_context()-&gt;get_media_router(
		/// ).
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_media_router_capi.h as
		/// cef_media_router_t* cef_media_router_get_global(_cef_completion_callback_t* callback)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_media_router_t* cef_media_router_get_global(cef_completion_callback_t* callback);

		/// <summary>
		/// Create a new MenuModel with the specified |delegate|.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_menu_model_capi.h as
		/// cef_menu_model_t* cef_menu_model_create(_cef_menu_model_delegate_t* delegate)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_menu_model_t* cef_menu_model_create(cef_menu_model_delegate_t* @delegate);

		/// <summary>
		/// Returns the current system trace time or, if none is defined, the current
		/// high-res time. Can be used by clients to synchronize with the time
		/// information in trace events.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_trace_capi.h as
		/// int64 cef_now_from_system_trace_time()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern long cef_now_from_system_trace_time();

		/// <summary>
		/// Parses the specified |json_string| and returns a dictionary or list
		/// representation. If JSON parsing fails this function returns NULL.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// _cef_value_t* cef_parse_json(const cef_string_t* json_string, cef_json_parser_options_t options)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_value_t* cef_parse_json(cef_string_t* json_string, CefJsonParserOptions options);

		/// <summary>
		/// Parses the specified UTF8-encoded |json| buffer of size |json_size| and
		/// returns a dictionary or list representation. If JSON parsing fails this
		/// function returns NULL.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// _cef_value_t* cef_parse_json_buffer(const void* json, size_t json_size, cef_json_parser_options_t options)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_value_t* cef_parse_json_buffer(void* json, UIntPtr json_size, CefJsonParserOptions options);

		/// <summary>
		/// Parses the specified |json_string| and returns a dictionary or list
		/// representation. If JSON parsing fails this function returns NULL and
		/// populates |error_msg_out| with a formatted error message.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// _cef_value_t* cef_parse_jsonand_return_error(const cef_string_t* json_string, cef_json_parser_options_t options, cef_string_t* error_msg_out)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_value_t* cef_parse_jsonand_return_error(cef_string_t* json_string, CefJsonParserOptions options, cef_string_t* error_msg_out);

		/// <summary>
		/// Parse the specified |url| into its component parts. Returns false (0) if the
		/// URL is NULL or invalid.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// int cef_parse_url(const cef_string_t* url, _cef_urlparts_t* parts)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_parse_url(cef_string_t* url, cef_urlparts_t* parts);

		/// <summary>
		/// Create a new cef_post_data_t object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_request_capi.h as
		/// cef_post_data_t* cef_post_data_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_post_data_t* cef_post_data_create();

		/// <summary>
		/// Create a new cef_post_data_element_t object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_request_capi.h as
		/// cef_post_data_element_t* cef_post_data_element_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_post_data_element_t* cef_post_data_element_create();

		/// <summary>
		/// Post a task for delayed execution on the specified thread. Equivalent to
		/// using cef_task_runner_t::GetForThread(threadId)-&gt;PostDelayedTask(task,
		/// delay_ms).
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_task_capi.h as
		/// int cef_post_delayed_task(cef_thread_id_t threadId, cef_task_t* task, int64 delay_ms)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_post_delayed_task(CefThreadId threadId, cef_task_t* task, long delay_ms);

		/// <summary>
		/// Post a task for execution on the specified thread. Equivalent to using
		/// cef_task_runner_t::GetForThread(threadId)-&gt;PostTask(task).
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_task_capi.h as
		/// int cef_post_task(cef_thread_id_t threadId, cef_task_t* task)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_post_task(CefThreadId threadId, cef_task_t* task);

		/// <summary>
		/// Create a new cef_print_settings_t object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_print_settings_capi.h as
		/// cef_print_settings_t* cef_print_settings_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_print_settings_t* cef_print_settings_create();

		/// <summary>
		/// Create a new cef_process_message_t object with the specified name.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_process_message_capi.h as
		/// cef_process_message_t* cef_process_message_create(const cef_string_t* name)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_process_message_t* cef_process_message_create(cef_string_t* name);

		/// <summary>
		/// Quit the CEF message loop that was started by calling cef_run_message_loop().
		/// This function should only be called on the main application thread and only
		/// if cef_run_message_loop() was used.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// void cef_quit_message_loop()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_quit_message_loop();

		/// <summary>
		/// Cause the plugin list to refresh the next time it is accessed regardless of
		/// whether it has already been loaded. Can be called on any thread in the
		/// browser process.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_web_plugin_capi.h as
		/// void cef_refresh_web_plugins()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_refresh_web_plugins();

		/// <summary>
		/// Register a new V8 extension with the specified JavaScript extension code and
		/// handler. Functions implemented by the handler are prototyped using the
		/// keyword &apos;native&apos;. The calling of a native function is restricted to the scope
		/// in which the prototype of the native function is defined. This function may
		/// only be called on the render process main thread.
		/// Example JavaScript extension code: &lt;pre&gt;// create the &apos;example&apos; global object if it doesn&apos;t already exist.
		/// if (!example)
		/// example = {};
		/// // create the &apos;example.test&apos; global object if it doesn&apos;t already exist.
		/// if (!example.test)
		/// example.test = {};
		/// (function() {
		/// // Define the function &apos;example.test.myfunction&apos;.
		/// example.test.myfunction = function() {
		/// // Call CefV8Handler::Execute() with the function name &apos;MyFunction&apos;
		/// // and no arguments.
		/// native function MyFunction();
		/// return MyFunction();
		/// };
		/// // Define the getter function for parameter &apos;example.test.myparam&apos;.
		/// example.test.__defineGetter__(&apos;myparam&apos;, function() {
		/// // Call CefV8Handler::Execute() with the function name &apos;GetMyParam&apos;
		/// // and no arguments.
		/// native function GetMyParam();
		/// return GetMyParam();
		/// });
		/// // Define the setter function for parameter &apos;example.test.myparam&apos;.
		/// example.test.__defineSetter__(&apos;myparam&apos;, function(b) {
		/// // Call CefV8Handler::Execute() with the function name &apos;SetMyParam&apos;
		/// // and a single argument.
		/// native function SetMyParam();
		/// if(b) SetMyParam(b);
		/// });
		/// // Extension definitions can also contain normal JavaScript variables
		/// // and functions.
		/// var myint = 0;
		/// example.test.increment = function() {
		/// myint += 1;
		/// return myint;
		/// };
		/// })();
		/// &lt;/pre&gt;Example usage in the page: &lt;pre&gt;// Call the function.
		/// example.test.myfunction();
		/// // Set the parameter.
		/// example.test.myparam = value;
		/// // Get the parameter.
		/// value = example.test.myparam;
		/// // Call another function.
		/// example.test.increment();
		/// &lt;/pre&gt;
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// int cef_register_extension(const cef_string_t* extension_name, const cef_string_t* javascript_code, cef_v8handler_t* handler)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_register_extension(cef_string_t* extension_name, cef_string_t* javascript_code, cef_v8handler_t* handler);

		/// <summary>
		/// Register a scheme handler factory with the global request context. An NULL
		/// |domain_name| value for a standard scheme will cause the factory to match all
		/// domain names. The |domain_name| value will be ignored for non-standard
		/// schemes. If |scheme_name| is a built-in scheme and no handler is returned by
		/// |factory| then the built-in scheme handler factory will be called. If
		/// |scheme_name| is a custom scheme then you must also implement the
		/// cef_app_t::on_register_custom_schemes() function in all processes. This
		/// function may be called multiple times to change or remove the factory that
		/// matches the specified |scheme_name| and optional |domain_name|. Returns false
		/// (0) if an error occurs. This function may be called on any thread in the
		/// browser process. Using this function is equivalent to calling cef_request_con
		/// text_t::cef_request_context_get_global_context()-&gt;register_scheme_handler_fac
		/// tory().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_scheme_capi.h as
		/// int cef_register_scheme_handler_factory(const cef_string_t* scheme_name, const cef_string_t* domain_name, cef_scheme_handler_factory_t* factory)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_register_scheme_handler_factory(cef_string_t* scheme_name, cef_string_t* domain_name, cef_scheme_handler_factory_t* factory);

		/// <summary>
		/// Register a plugin crash. Can be called on any thread in the browser process
		/// but will be executed on the IO thread.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_web_plugin_capi.h as
		/// void cef_register_web_plugin_crash(const cef_string_t* path)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_register_web_plugin_crash(cef_string_t* path);

		/// <summary>
		/// Remove an entry from the cross-origin access whitelist. Returns false (0) if
		/// |source_origin| is invalid or the whitelist cannot be accessed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_origin_whitelist_capi.h as
		/// int cef_remove_cross_origin_whitelist_entry(const cef_string_t* source_origin, const cef_string_t* target_protocol, const cef_string_t* target_domain, int allow_target_subdomains)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_remove_cross_origin_whitelist_entry(cef_string_t* source_origin, cef_string_t* target_protocol, cef_string_t* target_domain, int allow_target_subdomains);

		/// <summary>
		/// Creates a new context object with the specified |settings| and optional
		/// |handler|.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_request_context_capi.h as
		/// cef_request_context_t* cef_request_context_create_context(const const _cef_request_context_settings_t* settings, _cef_request_context_handler_t* handler)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_request_context_t* cef_request_context_create_context(cef_request_context_settings_t* settings, cef_request_context_handler_t* handler);

		/// <summary>
		/// Returns the global context object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_request_context_capi.h as
		/// cef_request_context_t* cef_request_context_get_global_context()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_request_context_t* cef_request_context_get_global_context();

		/// <summary>
		/// Create a new cef_request_t object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_request_capi.h as
		/// cef_request_t* cef_request_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_request_t* cef_request_create();

		/// <summary>
		/// Returns the global resource bundle instance.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_resource_bundle_capi.h as
		/// cef_resource_bundle_t* cef_resource_bundle_get_global()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_resource_bundle_t* cef_resource_bundle_get_global();

		/// <summary>
		/// Create a new cef_response_t object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_response_capi.h as
		/// cef_response_t* cef_response_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_response_t* cef_response_create();

		/// <summary>
		/// Run the CEF message loop. Use this function instead of an application-
		/// provided message loop to get the best balance between performance and CPU
		/// usage. This function should only be called on the main application thread and
		/// only if cef_initialize() is called with a
		/// CefSettings.multi_threaded_message_loop value of false (0). This function
		/// will block until a quit message is received by the system.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// void cef_run_message_loop()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_run_message_loop();

		/// <summary>
		/// Create a new server that binds to |address| and |port|. |address| must be a
		/// valid IPv4 or IPv6 address (e.g. 127.0.0.1 or ::1) and |port| must be a port
		/// number outside of the reserved range (e.g. between 1025 and 65535 on most
		/// platforms). |backlog| is the maximum number of pending connections. A new
		/// thread will be created for each CreateServer call (the &quot;dedicated server
		/// thread&quot;). It is therefore recommended to use a different cef_server_handler_t
		/// instance for each CreateServer call to avoid thread safety issues in the
		/// cef_server_handler_t implementation. The
		/// cef_server_handler_t::OnServerCreated function will be called on the
		/// dedicated server thread to report success or failure. See
		/// cef_server_handler_t::OnServerCreated documentation for a description of
		/// server lifespan.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_server_capi.h as
		/// void cef_server_create(const cef_string_t* address, uint16 port, int backlog, _cef_server_handler_t* handler)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_server_create(cef_string_t* address, ushort port, int backlog, cef_server_handler_t* handler);

		/// <summary>
		/// Sets or clears a specific key-value pair from the crash metadata.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_crash_util_capi.h as
		/// void cef_set_crash_key_value(const cef_string_t* key, const cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_set_crash_key_value(cef_string_t* key, cef_string_t* value);

		/// <summary>
		/// Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a
		/// modal message loop. Set to false (0) after exiting the modal message loop.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// void cef_set_osmodal_loop(int osModalLoop)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_set_osmodal_loop(int osModalLoop);

		/// <summary>
		/// This function should be called on the main application thread to shut down
		/// the CEF browser process before the application exits.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_app_capi.h as
		/// void cef_shutdown()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_shutdown();

		/// <summary>
		/// Create a new cef_stream_reader_t object from data.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_stream_capi.h as
		/// cef_stream_reader_t* cef_stream_reader_create_for_data(void* data, size_t size)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_stream_reader_t* cef_stream_reader_create_for_data(void* data, UIntPtr size);

		/// <summary>
		/// Create a new cef_stream_reader_t object from a file.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_stream_capi.h as
		/// cef_stream_reader_t* cef_stream_reader_create_for_file(const cef_string_t* fileName)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_stream_reader_t* cef_stream_reader_create_for_file(cef_string_t* fileName);

		/// <summary>
		/// Create a new cef_stream_reader_t object from a custom handler.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_stream_capi.h as
		/// cef_stream_reader_t* cef_stream_reader_create_for_handler(cef_read_handler_t* handler)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_stream_reader_t* cef_stream_reader_create_for_handler(cef_read_handler_t* handler);

		/// <summary>
		/// Create a new cef_stream_writer_t object for a file.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_stream_capi.h as
		/// cef_stream_writer_t* cef_stream_writer_create_for_file(const cef_string_t* fileName)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_stream_writer_t* cef_stream_writer_create_for_file(cef_string_t* fileName);

		/// <summary>
		/// Create a new cef_stream_writer_t object for a custom handler.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_stream_capi.h as
		/// cef_stream_writer_t* cef_stream_writer_create_for_handler(cef_write_handler_t* handler)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_stream_writer_t* cef_stream_writer_create_for_handler(cef_write_handler_t* handler);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_ascii_to_utf16(const char* src, size_t src_len, cef_string_utf16_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_ascii_to_utf16(byte* src, UIntPtr src_len, cef_string_utf16_t* output);

		/// <summary>
		/// These functions convert an ASCII string, typically a hardcoded constant, to a
		/// Wide/UTF16 string. Use instead of the UTF8 conversion routines if you know
		/// the string is ASCII.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_ascii_to_wide(const char* src, size_t src_len, cef_string_wide_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_ascii_to_wide(byte* src, UIntPtr src_len, cef_string_wide_t* output);

		/// <summary>
		/// Allocate a new string map.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_list.h as
		/// cef_string_list_t cef_string_list_alloc()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_list_t cef_string_list_alloc();

		/// <summary>
		/// Append a new value at the end of the string list.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_list.h as
		/// void cef_string_list_append(cef_string_list_t list, const cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_list_append(cef_string_list_t list, cef_string_t* value);

		/// <summary>
		/// Clear the string list.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_list.h as
		/// void cef_string_list_clear(cef_string_list_t list)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_list_clear(cef_string_list_t list);

		/// <summary>
		/// Creates a copy of an existing string list.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_list.h as
		/// cef_string_list_t cef_string_list_copy(cef_string_list_t list)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_list_t cef_string_list_copy(cef_string_list_t list);

		/// <summary>
		/// Free the string list.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_list.h as
		/// void cef_string_list_free(cef_string_list_t list)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_list_free(cef_string_list_t list);

		/// <summary>
		/// Return the number of elements in the string list.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_list.h as
		/// size_t cef_string_list_size(cef_string_list_t list)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern UIntPtr cef_string_list_size(cef_string_list_t list);

		/// <summary>
		/// Retrieve the value at the specified zero-based string list index. Returns
		/// true (1) if the value was successfully retrieved.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_list.h as
		/// int cef_string_list_value(cef_string_list_t list, size_t index, cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_list_value(cef_string_list_t list, UIntPtr index, cef_string_t* value);

		/// <summary>
		/// Allocate a new string map.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// cef_string_map_t cef_string_map_alloc()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_map_t cef_string_map_alloc();

		/// <summary>
		/// Append a new key/value pair at the end of the string map.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// int cef_string_map_append(cef_string_map_t map, const cef_string_t* key, const cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_map_append(cef_string_map_t map, cef_string_t* key, cef_string_t* value);

		/// <summary>
		/// Clear the string map.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// void cef_string_map_clear(cef_string_map_t map)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_map_clear(cef_string_map_t map);

		/// <summary>
		/// Return the value assigned to the specified key.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// int cef_string_map_find(cef_string_map_t map, const cef_string_t* key, cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_map_find(cef_string_map_t map, cef_string_t* key, cef_string_t* value);

		/// <summary>
		/// Free the string map.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// void cef_string_map_free(cef_string_map_t map)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_map_free(cef_string_map_t map);

		/// <summary>
		/// Return the key at the specified zero-based string map index.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// int cef_string_map_key(cef_string_map_t map, size_t index, cef_string_t* key)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_map_key(cef_string_map_t map, UIntPtr index, cef_string_t* key);

		/// <summary>
		/// Return the number of elements in the string map.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// size_t cef_string_map_size(cef_string_map_t map)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern UIntPtr cef_string_map_size(cef_string_map_t map);

		/// <summary>
		/// Return the value at the specified zero-based string map index.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_map.h as
		/// int cef_string_map_value(cef_string_map_t map, size_t index, cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_map_value(cef_string_map_t map, UIntPtr index, cef_string_t* value);

		/// <summary>
		/// Allocate a new string multimap.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// cef_string_multimap_t cef_string_multimap_alloc()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_multimap_t cef_string_multimap_alloc();

		/// <summary>
		/// Append a new key/value pair at the end of the string multimap.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// int cef_string_multimap_append(cef_string_multimap_t map, const cef_string_t* key, const cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_multimap_append(cef_string_multimap_t map, cef_string_t* key, cef_string_t* value);

		/// <summary>
		/// Clear the string multimap.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// void cef_string_multimap_clear(cef_string_multimap_t map)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_multimap_clear(cef_string_multimap_t map);

		/// <summary>
		/// Return the value_index-th value with the specified key.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// int cef_string_multimap_enumerate(cef_string_multimap_t map, const cef_string_t* key, size_t value_index, cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_multimap_enumerate(cef_string_multimap_t map, cef_string_t* key, UIntPtr value_index, cef_string_t* value);

		/// <summary>
		/// Return the number of values with the specified key.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// size_t cef_string_multimap_find_count(cef_string_multimap_t map, const cef_string_t* key)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern UIntPtr cef_string_multimap_find_count(cef_string_multimap_t map, cef_string_t* key);

		/// <summary>
		/// Free the string multimap.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// void cef_string_multimap_free(cef_string_multimap_t map)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_multimap_free(cef_string_multimap_t map);

		/// <summary>
		/// Return the key at the specified zero-based string multimap index.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// int cef_string_multimap_key(cef_string_multimap_t map, size_t index, cef_string_t* key)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_multimap_key(cef_string_multimap_t map, UIntPtr index, cef_string_t* key);

		/// <summary>
		/// Return the number of elements in the string multimap.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// size_t cef_string_multimap_size(cef_string_multimap_t map)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern UIntPtr cef_string_multimap_size(cef_string_multimap_t map);

		/// <summary>
		/// Return the value at the specified zero-based string multimap index.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_multimap.h as
		/// int cef_string_multimap_value(cef_string_multimap_t map, size_t index, cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_multimap_value(cef_string_multimap_t map, UIntPtr index, cef_string_t* value);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// cef_string_userfree_utf16_t cef_string_userfree_utf16_alloc()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_utf16_t cef_string_userfree_utf16_alloc();

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// void cef_string_userfree_utf16_free(cef_string_userfree_utf16_t str)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_userfree_utf16_free(cef_string_userfree_utf16_t str);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// cef_string_userfree_utf8_t cef_string_userfree_utf8_alloc()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_utf8_t cef_string_userfree_utf8_alloc();

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// void cef_string_userfree_utf8_free(cef_string_userfree_utf8_t str)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_userfree_utf8_free(cef_string_userfree_utf8_t str);

		/// <summary>
		/// These functions allocate a new string structure. They must be freed by
		/// calling the associated free function.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// cef_string_userfree_wide_t cef_string_userfree_wide_alloc()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_wide_t cef_string_userfree_wide_alloc();

		/// <summary>
		/// These functions free the string structure allocated by the associated
		/// alloc function. Any string contents will first be cleared.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// void cef_string_userfree_wide_free(cef_string_userfree_wide_t str)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_userfree_wide_free(cef_string_userfree_wide_t str);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// void cef_string_utf16_clear(cef_string_utf16_t* str)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_utf16_clear(cef_string_utf16_t* str);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf16_cmp(const cef_string_utf16_t* str1, const cef_string_utf16_t* str2)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf16_cmp(cef_string_utf16_t* str1, cef_string_utf16_t* str2);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf16_set(const char16* src, size_t src_len, cef_string_utf16_t* output, int copy)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf16_set(char* src, UIntPtr src_len, cef_string_utf16_t* output, int copy);

		/// <summary>
		/// These functions convert utf16 string case using the current ICU locale. This
		/// may change the length of the string in some cases.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf16_to_lower(const char16* src, size_t src_len, cef_string_utf16_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf16_to_lower(char* src, UIntPtr src_len, cef_string_utf16_t* output);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf16_to_upper(const char16* src, size_t src_len, cef_string_utf16_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf16_to_upper(char* src, UIntPtr src_len, cef_string_utf16_t* output);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf16_to_utf8(const char16* src, size_t src_len, cef_string_utf8_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf16_to_utf8(char* src, UIntPtr src_len, cef_string_utf8_t* output);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf16_to_wide(const char16* src, size_t src_len, cef_string_wide_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf16_to_wide(char* src, UIntPtr src_len, cef_string_wide_t* output);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// void cef_string_utf8_clear(cef_string_utf8_t* str)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_utf8_clear(cef_string_utf8_t* str);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf8_cmp(const cef_string_utf8_t* str1, const cef_string_utf8_t* str2)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf8_cmp(cef_string_utf8_t* str1, cef_string_utf8_t* str2);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf8_set(const char* src, size_t src_len, cef_string_utf8_t* output, int copy)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf8_set(byte* src, UIntPtr src_len, cef_string_utf8_t* output, int copy);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf8_to_utf16(const char* src, size_t src_len, cef_string_utf16_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf8_to_utf16(byte* src, UIntPtr src_len, cef_string_utf16_t* output);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_utf8_to_wide(const char* src, size_t src_len, cef_string_wide_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_utf8_to_wide(byte* src, UIntPtr src_len, cef_string_wide_t* output);

		/// <summary>
		/// These functions clear string values. The structure itself is not freed.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// void cef_string_wide_clear(cef_string_wide_t* str)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_string_wide_clear(cef_string_wide_t* str);

		/// <summary>
		/// These functions compare two string values with the same results as strcmp().
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_wide_cmp(const cef_string_wide_t* str1, const cef_string_wide_t* str2)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_wide_cmp(cef_string_wide_t* str1, cef_string_wide_t* str2);

		/// <summary>
		/// These functions set string values. If |copy| is true (1) the value will be
		/// copied instead of referenced. It is up to the user to properly manage
		/// the lifespan of references.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_wide_set(const wchar* src, size_t src_len, cef_string_wide_t* output, int copy)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_wide_set(char* src, UIntPtr src_len, cef_string_wide_t* output, int copy);

		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_wide_to_utf16(const wchar* src, size_t src_len, cef_string_utf16_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_wide_to_utf16(char* src, UIntPtr src_len, cef_string_utf16_t* output);

		/// <summary>
		/// These functions convert between UTF-8, -16, and -32 strings. They are
		/// potentially slow so unnecessary conversions should be avoided. The best
		/// possible result will always be written to |output| with the boolean return
		/// value indicating whether the conversion is 100% valid.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_string_types.h as
		/// int cef_string_wide_to_utf8(const wchar* src, size_t src_len, cef_string_utf8_t* output)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_string_wide_to_utf8(char* src, UIntPtr src_len, cef_string_utf8_t* output);

		/// <summary>
		/// Returns the task runner for the current thread. Only CEF threads will have
		/// task runners. An NULL reference will be returned if this function is called
		/// on an invalid thread.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_task_capi.h as
		/// cef_task_runner_t* cef_task_runner_get_for_current_thread()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_task_runner_t* cef_task_runner_get_for_current_thread();

		/// <summary>
		/// Returns the task runner for the specified CEF thread.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_task_capi.h as
		/// cef_task_runner_t* cef_task_runner_get_for_thread(cef_thread_id_t threadId)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_task_runner_t* cef_task_runner_get_for_thread(CefThreadId threadId);

		/// <summary>
		/// Create and start a new thread. This function does not block waiting for the
		/// thread to run initialization. |display_name| is the name that will be used to
		/// identify the thread. |priority| is the thread execution priority.
		/// |message_loop_type| indicates the set of asynchronous events that the thread
		/// can process. If |stoppable| is true (1) the thread will stopped and joined on
		/// destruction or when stop() is called; otherwise, the thread cannot be stopped
		/// and will be leaked on shutdown. On Windows the |com_init_mode| value
		/// specifies how COM will be initialized for the thread. If |com_init_mode| is
		/// set to COM_INIT_MODE_STA then |message_loop_type| must be set to ML_TYPE_UI.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_thread_capi.h as
		/// cef_thread_t* cef_thread_create(const cef_string_t* display_name, cef_thread_priority_t priority, cef_message_loop_type_t message_loop_type, int stoppable, cef_com_init_mode_t com_init_mode)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_thread_t* cef_thread_create(cef_string_t* display_name, CefThreadPriority priority, CefMessageLoopType message_loop_type, int stoppable, CefComInitMode com_init_mode);

		/// <summary>
		/// Retrieve the delta in milliseconds between two time values.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_time.h as
		/// int cef_time_delta(const cef_time_t* cef_time1, const cef_time_t* cef_time2, long long* delta)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_time_delta(cef_time_t* cef_time1, cef_time_t* cef_time2, long* delta);

		/// <remarks>
		/// Defined in include/internal/cef_time.h as
		/// int cef_time_from_doublet(double time, cef_time_t* cef_time)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_time_from_doublet(double time, cef_time_t* cef_time);

		/// <remarks>
		/// Defined in include/internal/cef_time.h as
		/// int cef_time_from_timet(time_t time, cef_time_t* cef_time)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_time_from_timet(IntPtr time, cef_time_t* cef_time);

		/// <summary>
		/// Retrieve the current system time.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_time.h as
		/// int cef_time_now(cef_time_t* cef_time)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_time_now(cef_time_t* cef_time);

		/// <summary>
		/// Converts cef_time_t to/from a double which is the number of seconds since
		/// epoch (Jan 1, 1970). Webkit uses this format to represent time. A value of 0
		/// means &quot;not initialized&quot;. Returns true (1) on success and false (0) on
		/// failure.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_time.h as
		/// int cef_time_to_doublet(const cef_time_t* cef_time, double* time)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_time_to_doublet(cef_time_t* cef_time, double* time);

		/// <summary>
		/// Converts cef_time_t to/from time_t. Returns true (1) on success and false (0)
		/// on failure.
		/// </summary>
		/// <remarks>
		/// Defined in include/internal/cef_time.h as
		/// int cef_time_to_timet(const cef_time_t* cef_time, time_t* time)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_time_to_timet(cef_time_t* cef_time, IntPtr* time);

		/// <summary>
		/// Unregister an internal plugin. This may be undone the next time
		/// cef_refresh_web_plugins() is called. Can be called on any thread in the
		/// browser process.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_web_plugin_capi.h as
		/// void cef_unregister_internal_web_plugin(const cef_string_t* path)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_unregister_internal_web_plugin(cef_string_t* path);

		/// <summary>
		/// Unescapes |text| and returns the result. Unescaping consists of looking for
		/// the exact pattern &quot;%XX&quot; where each X is a hex digit and converting to the
		/// character with the numerical value of those digits (e.g. &quot;i%20=%203%3b&quot;
		/// unescapes to &quot;i = 3;&quot;). If |convert_to_utf8| is true (1) this function will
		/// attempt to interpret the initial decoded result as UTF-8. If the result is
		/// convertable into UTF-8 it will be returned as converted. Otherwise the
		/// initial decoded result will be returned.  The |unescape_rule| parameter
		/// supports further customization the decoding process.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// cef_string_userfree_t cef_uridecode(const cef_string_t* text, int convert_to_utf8, cef_uri_unescape_rule_t unescape_rule)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_t cef_uridecode(cef_string_t* text, int convert_to_utf8, CefUriUnescapeRule unescape_rule);

		/// <summary>
		/// Escapes characters in |text| which are unsuitable for use as a query
		/// parameter value. Everything except alphanumerics and -_.!~*&apos;() will be
		/// converted to &quot;%XX&quot;. If |use_plus| is true (1) spaces will change to &quot;+&quot;. The
		/// result is basically the same as encodeURIComponent in Javacript.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// cef_string_userfree_t cef_uriencode(const cef_string_t* text, int use_plus)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_t cef_uriencode(cef_string_t* text, int use_plus);

		/// <summary>
		/// Create a new URL request that is not associated with a specific browser or
		/// frame. Use cef_frame_t::CreateURLRequest instead if you want the request to
		/// have this association, in which case it may be handled differently (see
		/// documentation on that function). A request created with this function may
		/// only originate from the browser process, and will behave as follows:
		/// - It may be intercepted by the client via CefResourceRequestHandler or
		/// CefSchemeHandlerFactory.
		/// - POST data may only contain only a single element of type PDE_TYPE_FILE
		/// or PDE_TYPE_BYTES.
		/// - If |request_context| is empty the global request context will be used.
		/// The |request| object will be marked as read-only after calling this function.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_urlrequest_capi.h as
		/// cef_urlrequest_t* cef_urlrequest_create(_cef_request_t* request, _cef_urlrequest_client_t* client, _cef_request_context_t* request_context)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_urlrequest_t* cef_urlrequest_create(cef_request_t* request, cef_urlrequest_client_t* client, cef_request_context_t* request_context);

		/// <summary>
		/// Returns the current (top) context object in the V8 context stack.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8context_t* cef_v8context_get_current_context()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8context_t* cef_v8context_get_current_context();

		/// <summary>
		/// Returns the entered (bottom) context object in the V8 context stack.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8context_t* cef_v8context_get_entered_context()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8context_t* cef_v8context_get_entered_context();

		/// <summary>
		/// Returns true (1) if V8 is currently inside a context.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// int cef_v8context_in_context()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_v8context_in_context();

		/// <summary>
		/// Returns the stack trace for the currently active context. |frame_limit| is
		/// the maximum number of frames that will be captured.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8stack_trace_t* cef_v8stack_trace_get_current(int frame_limit)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8stack_trace_t* cef_v8stack_trace_get_current(int frame_limit);

		/// <summary>
		/// Create a new cef_v8value_t object of type array with the specified |length|.
		/// If |length| is negative the returned array will have length 0. This function
		/// should only be called from within the scope of a
		/// cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,
		/// or in combination with calling enter() and exit() on a stored cef_v8context_t
		/// reference.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_array(int length)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_array(int length);

		/// <summary>
		/// Create a new cef_v8value_t object of type ArrayBuffer which wraps the
		/// provided |buffer| of size |length| bytes. The ArrayBuffer is externalized,
		/// meaning that it does not own |buffer|. The caller is responsible for freeing
		/// |buffer| when requested via a call to cef_v8array_buffer_release_callback_t::
		/// ReleaseBuffer. This function should only be called from within the scope of a
		/// cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,
		/// or in combination with calling enter() and exit() on a stored cef_v8context_t
		/// reference.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_array_buffer(void* buffer, size_t length, cef_v8array_buffer_release_callback_t* release_callback)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_array_buffer(void* buffer, UIntPtr length, cef_v8array_buffer_release_callback_t* release_callback);

		/// <summary>
		/// Create a new cef_v8value_t object of type bool.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_bool(int value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_bool(int value);

		/// <summary>
		/// Create a new cef_v8value_t object of type Date. This function should only be
		/// called from within the scope of a cef_render_process_handler_t,
		/// cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
		/// enter() and exit() on a stored cef_v8context_t reference.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_date(const cef_time_t* date)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_date(cef_time_t* date);

		/// <summary>
		/// Create a new cef_v8value_t object of type double.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_double(double value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_double(double value);

		/// <summary>
		/// Create a new cef_v8value_t object of type function. This function should only
		/// be called from within the scope of a cef_render_process_handler_t,
		/// cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
		/// enter() and exit() on a stored cef_v8context_t reference.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_function(const cef_string_t* name, cef_v8handler_t* handler)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_function(cef_string_t* name, cef_v8handler_t* handler);

		/// <summary>
		/// Create a new cef_v8value_t object of type int.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_int(int32 value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_int(int value);

		/// <summary>
		/// Create a new cef_v8value_t object of type null.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_null()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_null();

		/// <summary>
		/// Create a new cef_v8value_t object of type object with optional accessor
		/// and/or interceptor. This function should only be called from within the scope
		/// of a cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t
		/// callback, or in combination with calling enter() and exit() on a stored
		/// cef_v8context_t reference.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_object(cef_v8accessor_t* accessor, cef_v8interceptor_t* interceptor)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_object(cef_v8accessor_t* accessor, cef_v8interceptor_t* interceptor);

		/// <summary>
		/// Create a new cef_v8value_t object of type string.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_string(const cef_string_t* value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_string(cef_string_t* value);

		/// <summary>
		/// Create a new cef_v8value_t object of type unsigned int.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_uint(uint32 value)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_uint(uint value);

		/// <summary>
		/// Create a new cef_v8value_t object of type undefined.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_v8_capi.h as
		/// cef_v8value_t* cef_v8value_create_undefined()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_v8value_t* cef_v8value_create_undefined();

		/// <summary>
		/// Creates a new object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_values_capi.h as
		/// cef_value_t* cef_value_create()
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_value_t* cef_value_create();

		/// <summary>
		/// Returns CEF version information for the libcef library. The |entry|
		/// parameter describes which version component will be returned:
		/// 0 - CEF_VERSION_MAJOR
		/// 1 - CEF_VERSION_MINOR
		/// 2 - CEF_VERSION_PATCH
		/// 3 - CEF_COMMIT_NUMBER
		/// 4 - CHROME_VERSION_MAJOR
		/// 5 - CHROME_VERSION_MINOR
		/// 6 - CHROME_VERSION_BUILD
		/// 7 - CHROME_VERSION_PATCH
		/// </summary>
		/// <remarks>
		/// Defined in include/cef_version.h as
		/// int cef_version_info(int entry)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_version_info(int entry);

		/// <summary>
		/// Visit web plugin information. Can be called on any thread in the browser
		/// process.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_web_plugin_capi.h as
		/// void cef_visit_web_plugin_info(cef_web_plugin_info_visitor_t* visitor)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern void cef_visit_web_plugin_info(cef_web_plugin_info_visitor_t* visitor);

		/// <summary>
		/// Create a new waitable event. If |automatic_reset| is true (1) then the event
		/// state is automatically reset to un-signaled after a single waiting thread has
		/// been released; otherwise, the state remains signaled until reset() is called
		/// manually. If |initially_signaled| is true (1) then the event will start in
		/// the signaled state.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_waitable_event_capi.h as
		/// cef_waitable_event_t* cef_waitable_event_create(int automatic_reset, int initially_signaled)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_waitable_event_t* cef_waitable_event_create(int automatic_reset, int initially_signaled);

		/// <summary>
		/// Generates a JSON string from the specified root |node| which should be a
		/// dictionary or list value. Returns an NULL string on failure. This function
		/// requires exclusive access to |node| including any underlying data.
		/// The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_parser_capi.h as
		/// cef_string_userfree_t cef_write_json(_cef_value_t* node, cef_json_writer_options_t options)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_string_userfree_t cef_write_json(cef_value_t* node, CefJsonWriterOptions options);

		/// <summary>
		/// Create a new cef_xml_reader_t object. The returned object&apos;s functions can
		/// only be called from the thread that created the object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_xml_reader_capi.h as
		/// cef_xml_reader_t* cef_xml_reader_create(_cef_stream_reader_t* stream, cef_xml_encoding_type_t encodingType, const cef_string_t* URI)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_xml_reader_t* cef_xml_reader_create(cef_stream_reader_t* stream, CefXmlEncodingType encodingType, cef_string_t* URI);

		/// <summary>
		/// Writes the contents of |src_dir| into a zip archive at |dest_file|. If
		/// |include_hidden_files| is true (1) files starting with &quot;.&quot; will be included.
		/// Returns true (1) on success.  Calling this function on the browser process UI
		/// or IO threads is not allowed.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_file_util_capi.h as
		/// int cef_zip_directory(const cef_string_t* src_dir, const cef_string_t* dest_file, int include_hidden_files)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern int cef_zip_directory(cef_string_t* src_dir, cef_string_t* dest_file, int include_hidden_files);

		/// <summary>
		/// Create a new cef_zip_reader_t object. The returned object&apos;s functions can
		/// only be called from the thread that created the object.
		/// </summary>
		/// <remarks>
		/// Defined in include/capi/cef_zip_reader_capi.h as
		/// cef_zip_reader_t* cef_zip_reader_create(_cef_stream_reader_t* stream)
		/// </remarks>
		[DllImport("libcef", CallingConvention = CallingConvention.Cdecl)]
		public static unsafe extern cef_zip_reader_t* cef_zip_reader_create(cef_stream_reader_t* stream);
	}
}

